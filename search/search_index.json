{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to frads documentation","text":"<p>Date: 2022-10-26</p> <p>Version: 0.2.8</p> <p><code>frads</code> project is an open source, BSD-licensed library providing easy-to-use wrapper for Radiance rendering engine.</p>"},{"location":"#table-of-contents","title":"Table Of Contents","text":"<p>The documentation consists of three parts:</p> <ol> <li>Manual: containing manual pages for all the command-line-interfaces.</li> <li>How-To Guides: scenario-based how-to guides</li> <li>Reference: Code API</li> </ol>"},{"location":"#installation","title":"Installation","text":"<p>You can find installation instructions on our README.</p>"},{"location":"#project-overview","title":"Project Overview","text":"<p>Frads is an open-source library providing high-level abstraction of Radiance matrix-based simulation workflows.</p> <p>Frads automates setup of these simulations by providing end users with an open-source, high-level abstraction of the Radiance command-line workflow (Unix toolbox model), helping to reduce the steep learning curve and associated user errors. frads also provides the necessary infrastructure needed for seamless integration of Radiance and other modeling tools, such as EnergyPlus.</p>"},{"location":"#frads--intended-audience","title":"Intended audience","text":"<ol> <li>Developers who are interested in incorporating multi-phase matrix methods into their software and are seeking examples and guidance; i.e., LBNL-suggested default parameters and settings; and,</li> <li>Engineering firms, researchers, and students who are comfortable working in the command-line or Python scripting environment and tasked with a project that cannot be completed with existing tools.</li> </ol>"},{"location":"#frads--why-matrix-based-methods","title":"Why matrix-based methods?","text":"<p>Matrix algebraic methods reduce the time needed to perform accurate, ray-tracing based, annual daylight simulations by several orders of magnitude.</p>"},{"location":"#frads--why-frads","title":"Why frads?","text":"<p>A good deal of expertise is needed to set up the simulations properly to achieve the desired level of accuracy. frads provides users with tools (e.g., <code>mrad</code>) that automatically determine which matrix-based method to use then sets the associated simulation parameters, helping beginners learn the different matrix methods by observing the tools\u2019 behavior. The user is still required to understand basic concepts underlying matrix-based simulation methods (see tutorials).</p> <p>Matrix-based methods also enable accurate, ray-tracing generated, irradiance, illuminance, and luminance data to be available for run-time data exchange and co-simulations. frads provides users with tools that generate the appropriate Radiance-generated data then interfaces with the \u201cactuator\u201d EMS module in EnergyPlus or within the Spawn-of-EnergyPlus and Modelica co-simulation environment. This enables end users to evaluate the performance of buildings with manual- and automatically-controlled shading and daylighting systems or other site and building features that can change parametrically or on a time-step basis.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>This work was supported by the Assistant Secretary for Energy Efficiency and Renewable Energy, Building Technologies Program, of the U.S. Department of Energy, under Contract No. DE-AC02-05CH11231.</p>"},{"location":"how-to/","title":"Index","text":"<p>This part of the project documentation focuses on a problem-oriented approach. You'll tackle common tasks that you might have, with the help of the code provided in this project.</p> <ol> <li> <p>How to simulate spatial daylight autonomy using two-phase method?</p> </li> <li> <p>How to simulate spatial daylight autonomy using three-phase method?</p> </li> <li> <p>How to simulate annual glare index using five-phase method?</p> </li> <li> <p>How to simulate annual melanopic equivalent daylight illuminance?</p> </li> <li> <p>How to model dynamic shading control and daylight dimming with EnergyPlus?</p> </li> <li> <p>How to setup a simple rtrace workflow?</p> </li> </ol>"},{"location":"how-to/guide5/","title":"How to model dynamic shading control and daylight dimming with EnergyPlus?","text":""},{"location":"how-to/guide5/#objective","title":"Objective","text":"<p>This notebook shows how to use EnergyPlusAPI to control the complex fenestration system (CFS) state and implement daylight dimming.</p>"},{"location":"how-to/guide5/#prerequisites","title":"Prerequisites","text":"<p>In order to run this notebook, you will need to install the following:</p> <ul> <li>EnergyPlus to simulate building energy.</li> <li>frads to initialize EnergyPlus model, and to create cfs and daylighting dimming controls.</li> </ul> <p>Optional:</p> <ul> <li>pandas and matplotlib to analyze and plot data.</li> </ul> <p>You will also need an EnergyPlus model in an idf or epjson file format. The model should contain the following:</p> <ul> <li>at least one zone</li> <li>at least one fenestration system</li> </ul>"},{"location":"how-to/guide5/#workflow","title":"Workflow","text":"<ol> <li>Initialize an E+ model with an input of idf or epjs file.</li> <li>Create Complex Fenestration System (CFS) glazing system for each fenestration construction state and add to E+ model</li> <li>Create lighting objects and add to E+ model</li> <li>Define controller function for CFS construction states and daylight dimming</li> <li>Initialize pyenergyplus.api to simulate</li> </ol> <pre><code>graph LR\n    subgraph pyenergyplus.api simulation\n    D[Radiance model]&lt;--&gt;B[EPmodel];\n    B&lt;--&gt;H[controller function]\n    H&lt;--&gt;D;\n    end\n    A[idf/epjs] --&gt; |load epmodel| B;\n    C[lighting system] --&gt; B;\n    E[glazing/shading system]--&gt; B;</code></pre> <pre><code>graph LR\n    subgraph frads\n    B[WincalcEngine]\n    C[EnergyPlus]\n    D[Radiance]\n    end\n\n    A[IGSDB] --&gt; B;\n    B --&gt; D;\n    B --&gt; C;\n    C &lt;--&gt;D</code></pre>"},{"location":"how-to/guide5/#import-required-python-libraries","title":"Import required Python libraries","text":"<pre><code>import os\nfrom pathlib import Path\nimport sys \n\nfrom frads import epjson2rad, eprad, parsers, matrix, methods, sky, types, window\nimport pandas as pd\n</code></pre> <p>!!! note     You'll need to install EnergyPlus before proceeding.</p> <p>Importing EnergyPlus into Python is not so straightforward. You can run the following code to import EnergyPlusAPI if you had installed EnergyPlus in the default location for your operating system. If you had not installed EnergyPlus one of these location you'll need to  <code>append</code> the path to your <code>sys.path</code> before you can import EnergyPlusAPI. </p> <pre><code>srcloc = {'win32': 'C:\\\\', 'darwin': '/Applications', 'linux': '/usr/local'}\ndname  = [os.path.join(srcloc[sys.platform], d) for d in os.listdir(srcloc[sys.platform]) if d.startswith('EnergyPlus')]\nephome = dname.pop()\nif ephome not in sys.path:\n    sys.path.append(ephome)\n\nfrom pyenergyplus.api import EnergyPlusAPI\n</code></pre>"},{"location":"how-to/guide5/#load-energypluse-model","title":"Load EnergyPlus(E+) model","text":"<p>The example idf file is from the EnergyPlus ExampleFiles directory. The building is 15.24m X 15.24m, single zone with one south-facing window.</p> <p>Initialize an E+ model by calling <code>eprad.load_epmodel</code>with an input of idf or epjs file. The example used here can be downloaded from here.</p> <pre><code>idf_path = Path(\"1ZoneUncontrolled_win_1.idf\")\napi = EnergyPlusAPI()\nepmodel = eprad.load_epmodel(idf_path, api)\n</code></pre>"},{"location":"how-to/guide5/#example-1-shading-control-and-daylight-dimming","title":"Example 1 - shading control and daylight dimming","text":""},{"location":"how-to/guide5/#add-cfs-objects-to-e-model","title":"Add CFS objects to E+ model","text":"<p>Initialize a glazing system by calling <code>window.GlazingSystem()</code>. Then, use <code>add_glazing_layer</code> and <code>add_shading_layer</code>respectively, to add glazing and shading layer to the glazing system. <code>add_glazing_layer</code> takes in a <code>.dat</code> or <code>.json</code> file. <code>add_shading_layer</code> takes in a <code>.xml</code> file. Visit the IGSDB website to download  <code>.json</code> files for glazing and <code>.xml</code> files for shading. If not specify, the default gap between the layers is air at 0.0127m thickness. See Example 2 for how to customize a gap.</p> <p>Create an unshaded glazing system, consisted of one layer of 6mm clear glass with the default gap. </p> <pre><code>gs_unshaded = window.GlazingSystem()\ngs_unshaded.add_glazing_layer(\"products/CLEAR_6.DAT\")\n</code></pre> <p>This is how you get the name of the glazing system.</p> <pre><code>gs_unshaded.name\n</code></pre> <pre><code>'Generic Clear Glass'\n</code></pre> <p>Create a shaded glazing system, consisted of one layer of 6mm clear glass and one layer of shading: 2011-SA1.</p> <pre><code>gs_shaded = window.GlazingSystem()\ngs_shaded.add_glazing_layer(\"products/CLEAR_6.DAT\")\ngs_shaded.add_shading_layer(\"products/2011-SA1.XML\")\n</code></pre> <pre><code>gs_shaded.name\n</code></pre> <pre><code>'Generic Clear Glass_Satine 5500 5%, White Pearl'\n</code></pre> <p>After the adding glazing and shading layers to the glazing system, compute solar and the solar and photopic results using <code>compute_solar_photopic_results</code>. Need to re-compute each time when the glazing system layering composition changes.</p> <pre><code>gs_unshaded.compute_solar_photopic_results()\n</code></pre> <pre><code>gs_shaded.compute_solar_photopic_results()\n</code></pre> <p>Add the unshaded and shaded glazing systems to E+ model by calling <code>add_cfs</code>.</p> <pre><code>epmodel.add_cfs(gs_unshaded)\nepmodel.add_cfs(gs_shaded)\n</code></pre>"},{"location":"how-to/guide5/#add-lighting-objects-to-e-model","title":"Add lighting objects to E+ model","text":"<p>Use <code>add_lighting</code>to add a lighting object for each of the zones in the building.</p> <pre><code>epmodel.add_lighting()\n</code></pre> <p>This is a list of attributes of the EPModel class</p> <pre><code>epmodel.windows\n</code></pre> <pre><code>['Zn001:Wall001:Win001']\n</code></pre> <pre><code>epmodel.cfs\n</code></pre> <pre><code>['Generic Clear Glass', 'Generic Clear Glass_Satine 5500 5%, White Pearl']\n</code></pre> <pre><code>epmodel.lighting_zone\n</code></pre> <pre><code>['Light_ZONE ONE']\n</code></pre> <pre><code>epmodel.zones\n</code></pre> <pre><code>['ZONE ONE']\n</code></pre>"},{"location":"how-to/guide5/#request-output-variable","title":"Request output  variable","text":"<p>Use <code>request_output</code>to request output variable that are not in the input  idf file before the simulation run. <pre><code>epmodel.request_output(\"Surface Inside Face Solar Radiation Heat Gain Rate per Area\")\n</code></pre></p>"},{"location":"how-to/guide5/#initialize-radiance-model","title":"Initialize Radiance model","text":"<p>Create a Radiance model by calling <code>epjson2rad.epjson2rad</code>and passing in an epjs and epw files. The epjs file can be accessed by calling <code>epmodel.epjs</code>. The <code>epjson2rad.epjson2rad</code>function creates an <code>Objects</code>directory for material and geometry primitives and a <code>Resources</code>directory for transmission matrices (xml files). The <code>epjson2rad.epjson2rad</code>function also generates a <code>config</code>file, which contains information about simulation controls setting, site, model, and raysender. Use <code>methods.three_phase</code>to perform the three-phase method and generate the view and daylight matrices under the <code>Matrices</code>directory. Finally, load the view, daylight, and transmission matrices with <code>load_matrix</code>.</p> <pre><code>zone = epmodel.zones[0]\nfloor = epmodel.floors[0]\nwall_wndo = epmodel.walls_window[0]\n\n# generate Radiance model\n# generate view, daylight, and transmission matrices\nepjson2rad.epjson2rad(epmodel.epjs, epw=\"USA_CA_Oakland.Intl.AP.724930_TMY3.epw\")\ncfg_file = Path(f\"{zone}.cfg\")\nconfig = parsers.parse_mrad_config(cfg_file)\nconfig[\"SimControl\"][\"no_multiply\"] = \"true\"\nwith methods.assemble_model(config) as model:\n    mpath = methods.three_phase(model, config)\n\n# load matrices\nvmx_window1 = matrix.load_matrix(mpath.pvmx[f\"{floor}{wall_wndo}_window\"])\ndmx_window1 = matrix.load_matrix(mpath.dmx[f\"{wall_wndo}_window\"])\ntmx_unshaded = matrix.load_matrix(f\"Resources/Generic Clear Glass.xml\")\ntmx_shaded = matrix.load_matrix(f\"Resources/Generic Clear Glass_Satine 5500 5%, White Pearl.xml\")\n</code></pre>"},{"location":"how-to/guide5/#define-controller-function-for-shading-control-and-daylight-dimming","title":"Define controller function for shading control and daylight dimming","text":"<p>Control fenestration construction based on time; the window is shaded from 11:00 to 15:00; otherwise, unshaded. The nominal lighting power of the light is 30W, controlled with linear daylight dimming based on the workplane illuminance. The workplane illuminance at each timestep is computed by calling <code>matrix.multiply_rgb</code>and passing in the view, trasmission, daylight, and sky matrices. Sky matrix is generated by calling <code>sky.genskymtx</code>and passing in a <code>WeaData</code>and <code>WeaMetaData</code>objects.</p> <p>Data is accessed through handles, which can be accessed by calling the <code>handles</code>attribute of the <code>EnergyPlusSetup</code>class.  Call <code>get_variable_value</code>and pass in a variable handle to get a variable value (e.g. Direct normal irradiance and diffuse horizontal irradiance). Call <code>actuate</code>and pass in an actuactor handle and value to set the actuator value.</p> <pre><code>def controller(state):\n    nominal_lighting_power = 30\n\n    shade_names = {\n        0: \"Generic Clear Glass\",\n        1: \"Generic Clear Glass_Satine 5500 5%, White Pearl\",\n    }\n\n    dt = ep.get_datetime()\n    direct_normal_irradiance = ep.get_variable_value(\n        ep.handles.direct_normal_irradiance\n    )\n    diffuse_horizontal_irradiance = ep.get_variable_value(\n        ep.handles.diffuse_horizontal_irradiance\n    )\n\n    ## control CFS construction\n    window_handle = ep.handles.window_actuators[\"Zn001:Wall001:Win001\"]\n\n    # change the fenestration to shaded\n    if dt.hour &gt; 10 and dt.hour &lt; 15:\n        _shades = 1\n        tmx = tmx_shaded\n    else:\n        _shades = 0\n        tmx = tmx_unshaded\n\n    ep.actuate(\n        window_handle, ep.handles.complex_fenestration_state[shade_names[_shades]]\n    )\n\n    ## control lights\n    light_handle = ep.handles.light_actuators[\"Light_ZONE ONE\"]\n\n    # create WeaData object to create smx\n    weadata = types.WeaData(\n        time=dt, dni=direct_normal_irradiance, dhi=diffuse_horizontal_irradiance\n    )\n    # initialize sky/sun matrix\n    smx = matrix.load_matrix(sky.genskymtx([weadata], meta, mfactor=4))\n    # get workplane illuminance\n    wpi = matrix.multiply_rgb(vmx_window1, tmx, dmx_window1, smx, weights=[47.4, 119.9, 11.6])\n    avg_wpi = wpi.mean()\n\n    # lighting power, assuming linear dimming curve\n    lighting_power = (1 - min(avg_wpi / 500, 1)) * nominal_lighting_power\n\n    ep.actuate(light_handle, lighting_power)\n</code></pre>"},{"location":"how-to/guide5/#initialize-pyenergyplusapi-to-simulate","title":"Initialize pyenergyplus.api to simulate","text":"<p>Register the controller functions to be call back by EnergyPlus by calling <code>set_callback</code>and passing in a callback point and function. To simulate, use <code>run</code>with optional parameters: <code>-w</code>weather file, <code>-d</code>output directory, and <code>-p</code>output prefix (default: eplus).</p> <p>Refer to Application Guide for EMS for descriptions of the calling points .</p> <pre><code>\"The calling point called \u201cBeginTimestepBeforePredictor\u201d occurs near the beginning of each timestep\nbut before the predictor executes. \u201cPredictor\u201d refers to the step in EnergyPlus modeling when the\nzone loads are calculated. This calling point is useful for controlling components that affect the\nthermal loads the HVAC systems will then attempt to meet. Programs called from this point\nmight actuate internal gains based on current weather or on the results from the previous timestep.\nDemand management routines might use this calling point to reduce lighting or process loads,\nchange thermostat settings, etc.\"\n</code></pre> <pre><code>with eprad.EnergyPlusSetup(api, epmodel.epjs) as ep:\n\n    # create WeaMetaData object to create smx\n    loc = list(epmodel.epjs[\"Site:Location\"].values())[0]\n    meta = types.WeaMetaData(\n        city=\"\",\n        country=\"\",\n        elevation=loc[\"elevation\"],\n        latitude=loc[\"latitude\"],\n        longitude=0 - loc[\"longitude\"],\n        timezone=(0 - loc[\"time_zone\"]) * 15,\n    )\n\n    ep.set_callback(\"callback_begin_system_timestep_before_predictor\", controller)\n    ep.run(weather_file=\"USA_CA_Oakland.Intl.AP.724930_TMY3.epw\", output_prefix=\"1ZoneUncontrolled_win_1\")\n</code></pre>"},{"location":"how-to/guide5/#load-and-visualize-results","title":"Load and visualize results","text":"<p>Use <code>pd.read_csv</code>to read the output csv file.</p> <pre><code>df = pd.read_csv(\n    \"./1ZoneUncontrolled_win_1out.csv\", index_col=0, parse_dates=True, date_parser=eprad.ep_datetime_parser\n)\n</code></pre> <p>Plot data on 07/21</p> <pre><code>df_0721 = df.loc[\"1900-07-21\"]\n</code></pre> <p>From 11:00 to 15:00, the window is shaded, where the fenestration construction is Generic Clear Glass_Satine 5500 5%, White Pearl. Otherwise, the window is unshaded, where the fenestration construction is Generic Clear Glass. The drop in transmitted solar radiation from 11:00 to 15:00 reflects the change in fenestration state from unshaded to shaded. The light is linearly dimmed in response to the workplane illuminance. Before the sunrise and after the sunset, the light is in full power. Then, in the morning from 5:30 to 11:00, when the window is unshaded, the lighting power decreases as the workplane illuminance increases; likewise inversely happened in the afternoon from 15:00 until the sunset. From 11:00 to 15:00, the lighting power is higher because the workplane illuminance decreases with the window changed to shaded.</p> <pre><code>fig, ax = plt.subplots()\nax.plot(\n    df_0721[\n        \"ZN001:WALL001:WIN001:Surface Window Transmitted Solar Radiation Rate [W](TimeStep)\"\n    ],\n    c=\"k\",\n    linestyle=\"-\",\n    label=\"ZN001:WALL001:WIN001\",\n)\nax1 = ax.twinx()\nax.xaxis.set_major_formatter(mdates.DateFormatter(\"%H:%M\"))\nax1.plot(\n    df_0721[\"LIGHT_ZONE ONE:Lights Electricity Rate [W](TimeStep)\"],\n    c=\"k\",\n    linestyle=\"--\",\n    label=\"LIGHT_ZONE ONE (right)\",\n)\n\nax.axvspan(datetime.datetime.strptime(\"1900-07-21 11:00\", \"%Y-%m-%d %H:%M\"), \n(datetime.datetime.strptime(\"1900-07-21 15:00\", \"%Y-%m-%d %H:%M\")), color=\"0.9\")\nax.annotate('Shaded',\n            xy=(datetime.datetime.strptime(\"1900-07-21 13:00\", \"%Y-%m-%d %H:%M\"), 2250),\n            ha='center', color=\"r\")\nax.annotate('Unshaded',\n            xy=(datetime.datetime.strptime(\"1900-07-21 5:00\", \"%Y-%m-%d %H:%M\"), 2250),\n            ha='center', color=\"r\")\nax.annotate('Unshaded',\n            xy=(datetime.datetime.strptime(\"1900-07-21 21:30\", \"%Y-%m-%d %H:%M\"), 2250),\n            ha='center', color=\"r\")\n\n\nax.set(xlabel=\"Time\", ylabel=\"Window Transmitted Solar Radiation Rate [W]\")\nax1.set(ylabel=\"Lights Electricity Rate [W]\")\nfig.legend(loc=\"center\", bbox_to_anchor=(0.5, 1.01), ncol=2, frameon=False)\nplt.tight_layout()\n</code></pre> <p></p> <p>Plot interior surfaces solar radiation heat gain rate per area</p> <pre><code>fig, ax = plt.subplots()\ny_vals = [\n    col\n    for col in df_0721.columns\n    if \"Surface Inside Face Solar Radiation Heat Gain Rate per Area\" in col\n]\n\nfor y_val in y_vals:\n    ax.plot(\n        df_0721[y_val],\n        linestyle=\"-\",\n        label=y_val.split(\":Surface\")[0],\n    )\n    ax.xaxis.set_major_formatter(mdates.DateFormatter(\"%H:%M\"))\n\nax.set(xlabel=\"Time\", ylabel=\"Solar Radiation Heat Gain Rate per Area [W/m2]\")\nfig.legend(loc=\"center\", bbox_to_anchor=(0.5, 1.01), ncol=3, frameon=False)\nplt.tight_layout()\n</code></pre> <p></p>"},{"location":"how-to/guide5/#check-implementation","title":"Check implementation","text":"<p>Check if the simulation is implemented correctly. Compare simulation results generated with the controller and no controller. </p> <p>Simulate an unshaded single pane CFS state and not control by a controller function.</p> <pre><code>epmodel.epjs[\"FenestrationSurface:Detailed\"][\"Zn001:Wall001:Win001\"][\"construction_name\"] = \"Generic Clear Glass\"\nwith eprad.EnergyPlusSetup(api, epmodel.epjs) as ep:\n    ep.run(\n        weather_file=\"USA_CA_Oakland.Intl.AP.724930_TMY3.epw\",\n        output_prefix=\"single_glass\",\n    )\n</code></pre> <pre><code>df = pd.read_csv(\n    \"./single_glassout.csv\",\n    index_col=0,\n    parse_dates=True,\n    date_parser=eprad.ep_datetime_parser,\n)\ndf_0721 = df.loc[\"1900-07-21\"]\n\nfig, ax = plt.subplots()\ny_vals = [\n    col\n    for col in df_0721.columns\n    if \"Surface Inside Face Solar Radiation Heat Gain Rate per Area\" in col\n]\n\nfor y_val in y_vals:\n    ax.plot(\n        df_0721[y_val],\n        linestyle=\"-\",\n        label=y_val.split(\":Surface\")[0],\n    )\n    ax.xaxis.set_major_formatter(mdates.DateFormatter(\"%H:%M\"))\n\nax.set(xlabel=\"Time\", ylabel=\"Solar Radiation Heat Gain Rate per Area [W/m2]\")\nfig.legend(loc=\"center\", bbox_to_anchor=(0.5, 1.01), ncol=3, frameon=False)\nplt.tight_layout()\n</code></pre> <p></p>"},{"location":"how-to/guide5/#example-2-electrochromic-glass-with-4-tinted-states","title":"Example 2 - electrochromic glass with 4 tinted states","text":""},{"location":"how-to/guide5/#add-4-tinted-electrochromic-states-to-e-model","title":"Add 4 tinted electrochromic states to E+ model","text":"<p>Each glazing system is consisted of one layer of ec glass and one layer of clear glass. The gap between the glasses is 10% air and 90% argon. The default gap is air at 0.0127m thickness. To customize the gap, use the <code>gaps</code>attribute of the <code>GlazingSystem</code>class. The <code>gaps</code>attribute is a list of tuples. Each tuple consists of tuples, where the first item is the gas type and the second item is the gas ratio, and a float for the gap thickness. The default thickness is 0.0127m. Also, to customize the name of the glazing system, use the <code>name</code>attribute of the <code>GlazingSystem</code>class.</p> <pre><code>gs_ec01 = window.GlazingSystem()\ngs_ec01.add_glazing_layer(\n    \"products/igsdb_product_7405.json\"\n)  # SageGlass SR2.0_7mm lami fully tinted 1%T\ngs_ec01.add_glazing_layer(\"products/CLEAR_3.DAT\")\ngs_ec01.gaps = [((window.AIR, 0.1), (window.ARGON, 0.9), 0.0127)]\ngs_ec01.name = \"ec01\"\n\ngs_ec06 = window.GlazingSystem()\ngs_ec06.add_glazing_layer(\n    \"products/igsdb_product_7407.json\"\n)  # SageGlass\u00ae SR2.0_7mm lami int state 6%T\ngs_ec06.add_glazing_layer(\"products/CLEAR_3.DAT\")\ngs_ec06.gaps = [((window.AIR, 0.1), (window.ARGON, 0.9), 0.0127)]\ngs_ec06.name = \"ec06\"\n\ngs_ec18 = window.GlazingSystem()\ngs_ec18.add_glazing_layer(\n    \"products/igsdb_product_7404.json\"\n)  # SageGlass\u00ae SR2.0_7mm lami int state 18%T\ngs_ec18.add_glazing_layer(\"products/CLEAR_3.DAT\")\ngs_ec18.gaps = [((window.AIR, 0.1), (window.ARGON, 0.9), 0.0127)]\ngs_ec18.name = \"ec18\"\n\ngs_ec60 = window.GlazingSystem()\ngs_ec60.add_glazing_layer(\n    \"products/igsdb_product_7406.json\"\n)  # SageGlass\u00ae SR2.0_7mm lami full clear 60%T\ngs_ec60.add_glazing_layer(\"products/CLEAR_3.DAT\")\ngs_ec60.gaps = [((window.AIR, 0.1), (window.ARGON, 0.9), 0.0127)]\ngs_ec60.name = \"ec60\"\n</code></pre> <pre><code>gs_ec01.compute_solar_photopic_results()\ngs_ec06.compute_solar_photopic_results()\ngs_ec18.compute_solar_photopic_results()\ngs_ec60.compute_solar_photopic_results()\n</code></pre> <pre><code>epmodel.add_cfs(gs_ec01)\nepmodel.add_cfs(gs_ec06)\nepmodel.add_cfs(gs_ec18)\nepmodel.add_cfs(gs_ec60)\n</code></pre>"},{"location":"how-to/guide5/#define-controller-function-for-the-ec-states","title":"Define controller function for the EC states","text":"<p>The elctrochromic glasses are controlled by time for the purpose of this demostration.</p> <pre><code>def ec_controller(state):\n    shade_names = {\n        0: \"ec01\",\n        1: \"ec06\",\n        2: \"ec18\",\n        3: \"ec60\",\n    }\n\n    dt = ep.get_datetime()\n    # print(dt.month)\n\n    ## control CFS construction\n    window_handle = ep.handles.window_actuators[\"Zn001:Wall001:Win001\"]\n\n    #change the fenestration to shaded\n    if dt.hour &gt;= 8 and dt.hour &lt; 12:\n        _shades = 2\n    elif dt.hour &gt; 12 and dt.hour &lt; 17:\n        _shades = 1\n    elif dt.hour == 12:\n        _shades = 0\n    else:\n        _shades = 3\n\n    ep.actuate(\n        window_handle, ep.handles.complex_fenestration_state[shade_names[_shades]]\n    )\n</code></pre>"},{"location":"how-to/guide5/#initialize-pyenergyplusapi-to-simulate_1","title":"Initialize pyenergyplus.api to simulate","text":"<pre><code>with eprad.EnergyPlusSetup(api, epmodel.epjs) as ep:\n    ep.set_callback(\"callback_begin_system_timestep_before_predictor\", ec_controller)\n    ep.run(\n        weather_file=\"USA_CA_Oakland.Intl.AP.724930_TMY3.epw\",\n        output_prefix=\"ec\",\n    )\n</code></pre>"},{"location":"how-to/guide5/#load-and-visualize-results_1","title":"Load and visualize results","text":"<pre><code>df = pd.read_csv(\n    \"./ecout.csv\",\n    index_col=0,\n    parse_dates=True,\n    date_parser=eprad.ep_datetime_parser,\n)\ndf_0721 = df.loc[\"1900-07-21\"]\n\nfig, ax = plt.subplots()\nax.plot(\n    df_0721[\n        \"ZN001:WALL001:WIN001:Surface Window Transmitted Solar Radiation Rate [W](TimeStep)\"\n    ],\n    c=\"k\",\n    linestyle=\"-\",\n    label=\"ZN001:WALL001:WIN001\",\n)\nax.xaxis.set_major_formatter(mdates.DateFormatter(\"%H:%M\"))\n\nax.axvspan(datetime.datetime.strptime(\"1900-07-21 8:00\", \"%Y-%m-%d %H:%M\"), \n(datetime.datetime.strptime(\"1900-07-21 12:00\", \"%Y-%m-%d %H:%M\")), color=\"0.93\")\nax.axvspan(datetime.datetime.strptime(\"1900-07-21 13:00\", \"%Y-%m-%d %H:%M\"), \n(datetime.datetime.strptime(\"1900-07-21 17:00\", \"%Y-%m-%d %H:%M\")), color=\"0.85\")\nax.axvspan(datetime.datetime.strptime(\"1900-07-21 12:00\", \"%Y-%m-%d %H:%M\"), \n(datetime.datetime.strptime(\"1900-07-21 13:00\", \"%Y-%m-%d %H:%M\")), color=\"0.8\")\n\nax.annotate('EC60%',\n            xy=(datetime.datetime.strptime(\"1900-07-21 4:30\", \"%Y-%m-%d %H:%M\"), 275),\n            ha='center', color=\"r\")\nax.annotate('18%',\n            xy=(datetime.datetime.strptime(\"1900-07-21 10:00\", \"%Y-%m-%d %H:%M\"), 275),\n            ha='center', color=\"r\")\nax.annotate('6%',\n            xy=(datetime.datetime.strptime(\"1900-07-21 15:00\", \"%Y-%m-%d %H:%M\"), 275),\n            ha='center', color=\"r\")\nax.annotate('1%',\n            xy=(datetime.datetime.strptime(\"1900-07-21 12:30\", \"%Y-%m-%d %H:%M\"), 275),\n            ha='center', color=\"r\")\nax.annotate('60%',\n            xy=(datetime.datetime.strptime(\"1900-07-21 21:00\", \"%Y-%m-%d %H:%M\"), 275),\n            ha='center', color=\"r\")\n\n\nax.set(xlabel=\"Time\", ylabel=\"Window Transmitted Solar Radiation Rate [W]\")\nplt.tight_layout()\n</code></pre> <pre><code>\n</code></pre>"},{"location":"how-to/guide6/","title":"How to set up a simple rtrace workflow.","text":"<p>Here we go through the process of setting up a simple Radiance model and the workflow of computing irradiance values.</p>"},{"location":"how-to/guide6/#prepare-a-model","title":"Prepare a model","text":"<p>If you already have a Radiance model setup, you can skip this step and follow along using your own.</p> <p>If you don't have a model already we can use <code>genradroom</code> to get ourself a simple Radiance model.</p> <p>Let's generate a open-office sized side-lit room with four same-sized windows. The room will be 12 meters wide, 14 meters deep with a ceiling height of 3 meters. Each window is 2.5 meters in width and 1.8 meters in height and has a sill height of 1 meter. Windows are 0.4 meters apart from each other. Finally, we want our facade to have a thickness of 0.1 meters. We'll call this model 'aroom'. The <code>genradroom</code> command is:</p> <pre><code>$ gen room 12 14 3 \\\n    -w 0.4 1 2.5 1.8 \\\n    -w 3.3 1 2.5 1.8 \\\n    -w 6.2 1 2.5 1.8 \\\n    -w 9.1 1 2.5 1.8 \\\n    -t 0.1 -n aroom\n</code></pre> <p>Afterwards, we will have a <code>Objects</code> folder in our current working directory with all of our Radiance model inside.</p> <p><pre><code>|____Objects\n| |____window_3_aroom.rad\n| |____wall_aroom.rad\n| |____window_2_aroom.rad\n| |____ceiling_aroom.rad\n| |____window_1_aroom.rad\n| |____materials_aroom.mat\n| |____window_0_aroom.rad\n| |____floor_aroom.rad\n</code></pre> We can quickly visualize our model using <code>objview</code> and make sure it's what we'd expect in terms of layout and geometry. <pre><code>objview Objects/*aroom.mat Objects/*aroom.rad\n</code></pre> And we can see that it is what we'd expect.</p> <p>{: style=\"height:343px;width:321px\"}</p>"},{"location":"how-to/guide6/#generate-an-octree-file","title":"Generate an octree file","text":"<p>Now that we have model, we can start to run some actual simulation. Each code block below can be copy and paste into a something like a Jupyter Lab for an interactive workflow.</p> <p>First lets import all the necessary modules. <pre><code>from frads import matrix\nfrom frads import parsers\nfrom frads import sky\nfrom frads import utils\nfrom frads.types import WeaData\nfrom frads.types import WeaMetaData\n</code></pre></p> <p>Next lets gather our model files. Notice that we have our material files first in the list.</p> <pre><code>fpaths = [\"Objects/materials_aroom.mat\",\n          \"Objects/ceiling_aroom.rad\",\n          \"Objects/wall_aroom.rad\",\n          \"Objects/floor_aroom.rad\",\n          \"Objects/window_0_aroom.rad\",\n          \"Objects/window_1_aroom.rad\",\n          \"Objects/window_2_aroom.rad\",\n          \"Objects/window_3_aroom.rad\",\n]\n</code></pre> <p>Now that we know where all the paths are, we can call <code>oconv</code> to get ourself a <code>octree</code> for ray tracing. We'd like to save our octree as a <code>aroom.oct</code> file.</p> <pre><code>room_octree = \"aroom.oct\"\nmatrix.oconv(*fpaths, room_octree)\n</code></pre> <p>Notices that we have a <code>aroom.oct</code>, which only contains the geometry. We need to define our light source, usually some kind of sky model, for rays to trace to. In this example, we will use Perez all-weather sky model. There are also standard CIE skies as alternatives. To do so, we can use <code>gen_perez_sky</code> function to get our sky description and generate a new octree with it.</p> <p>First to get our sky description, we make up a clear sky on 12-21 12:00 with direct normal irradiance of 800 W/m2 and diffuse horizontal irradiance of 100 W/m2. We also need to define our location in terms of latitude, longitude, time-zone, and elevation. We can then put all these information into the <code>WeaData</code> and <code>WeaMetaData</code> object.</p> <p><pre><code>month = 12\nday = 21\nhours = 12\ndni = 800\ndhi = 100\nlatitude = 37\nlongitude = 122\ntime_zone = 120\nelevation = 0\nwea_data = WeaData(month, day, hour, minutes, hours, dni, dhi)\nwea_meta = WeaMetaData(latitude, longitude, time_zone, elevation)\nsky_descr = sky.gen_perez_sky(wea_data, wea_meta)\n</code></pre> Once we have our sky description, we can combine it with our <code>aroom.oct</code> octree to make a new octree file. Let's call the octree with our sky specific information, 'aroom_37_122_1221_1200.oct'. <pre><code>room_sky_octree = f'aroom_{latitude}_{longitude}_{month:02d}{day:02d}_{hour:02d}{minute:02d}.oct'\nmatrix.oconv(room_sky_octree, input=sky_descr, octree=room_octree)\n</code></pre></p>"},{"location":"how-to/guide6/#get-rays","title":"Get rays","text":"<p>We need send rays to the octree file we just created. In Radiance, rays are made of two vectors, one for the starting position and one for the direction the ray is heading. Essentially, we need six values to define our two vectors in cartesian corrdiantes. A ray positioned at x=0, y=0, z=0, pointing upwards is thus: <pre><code>0 0 0 0 0 1\n</code></pre> For this example, we're gonna simulate workplane illuminance. These are essentially virtual sensor positioned at table height pointing upwards, measuring how much light arrives at your table. To get a grid of such sensors, we can use <code>gen_grid</code> utility function, which need a <code>polygon</code>, <code>spacing</code>, and <code>height</code> as arguments. Spacing and height define the grid spacing and the distance from the polygon from which the grid is based-one. Since we are generating a grid of workplane sensors, we can use our floor as the polygon. To get our floor polygon, we can simply load in our <code>floor_aroom.rad</code> file and parse the polygon using the <code>parse_polygon</code> function from the <code>parsers</code> module. The code block demonstrates how we generate a grid of sensors with 1 meter spacing and 0.75 meters away from the floor:</p> <pre><code>floor_primitives = utils.unpack_primitive(\"Objects/floor_aroom.rad\")\n# Since we only have one primitive in this file,\n# we'll take the first one to parse.\nfloor_polygon = parsers.parse_polygon(floor_primitives[0].real_arg)\ngrid = utils.gen_grid(floor_polygon, 1, 0.75)\n</code></pre>"},{"location":"how-to/guide6/#lets-trace","title":"Let's trace","text":"<p>Finally, after all these preparation, we are ready to trace some rays. Let's first trace a single ray, and use the one of the grid sensors we had just created.</p> <p><pre><code>aray = \" \".join(map(str, grid[0]))\noption = \"-I+ -ab 1 -ad 64 -aa 0 -lw 0.01\"\nresult = matrix.rtrace(aray, option, room_sky_octree)\n</code></pre> if we print the <code>result</code>, we will see the following: <pre><code>&gt;&gt;&gt; print(result)\n#?RADIANCE\n...\n\n3.23E+01 1.23E+02 7.80E+01\n</code></pre> Below the header, we can see three values, corresponding to red, green, and blue channel from our simulation. We can weight these RGB to derive our illuminance values.</p> <p>First we need get rid of the header. We can do that by passing <code>header=False</code> when we call rtrace. Or like so: <pre><code>result = result.split(\"\\n\\n\", 1)[1:]\nilluminance = matrix.weighting(result, (47.3, 119.9, 11.6))\n</code></pre> If we print out <code>illuminance</code>, we have: <pre><code>&gt;&gt;&gt; print(illuminance)\n2343.1\n</code></pre></p> <p>Next, let's trace all of our grid sensors. Since our grid of sensors are a list of lists of floats, we need to process them a little bit before rtrace can take them.</p> <p><pre><code>rays = \"\\n\".join([\" \".join(map(str, row)) for row in grid])\nresults = matrix.rtrace(rays, option, room_sky_octree, header=False)\n</code></pre> And our results, now with the header, is the following: <pre><code>\n</code></pre> After weighting these RGB values to obtain illuminance values, it'd be nice if we can visualize it somehow. One of the most common approach to visualize illuminance values over a grid of sensors is to map these values to a color scale.  There are many ways to achieve. Here we're gonna stay in the Python world and use the popular matplotlib library to visualize our results. favorite</p>"},{"location":"manual/","title":"Index","text":"<p>Frads CLI manual</p> <ul> <li>mrad</li> <li>gen</li> <li>gencolorsky</li> </ul>"},{"location":"manual/gencolorsky/","title":"gencolorsky","text":"<p><pre><code>gencolorsky &lt;year&gt; &lt;month&gt; &lt;day&gt; &lt;hour&gt; &lt;minute&gt; [options]\n</code></pre> Gencolorsky uses libRadtran to compute spatially- and spectrally-resolved sky radiation data based on an Earth\u2019s spherical atmosphere radiative transfer model that includes Rayleigh scattering by air molecules, molecular absorption, aerosol, water, and ice clouds. One of the main command-line programs in libRadtran, uvspec, is invoked to compute the sky radiance at every r\u00b0 (default 3\u00b0) in both the azimuth and altitude directions.  Within uvspec, the DISORT radiative transfer solver is used.  Extraterrestrial solar source data (280-800 nm), at 1nm interval, are used to generate spectrally-resolved sky radiation data at each sample point, which by default is computed at a 10 nm interval from 360 nm to 800 nm. By default, this sky spectral data is converted to Radiance RGB using CIE XYZ tristimulus with either the 2\u00b0 or 10\u00b0 standard observer, using user defined color space (default: Radiance RGB). If -i setting is used, the resulting three channels become photopic (CIE-Y), melanopic equivalent daylight il/luminance (EDI), and solar ir/radiance, respectively. The output is a folder called cs_{datetime}{lat}{lon} in the current working directory, containing a sky.rad file along with associated color data. The options to gencolorsky are can be found using <code>-h</code> flag on the command line.</p>"},{"location":"manual/gencolorsky/#options","title":"Options","text":"<p><code>-a/--latitude</code> :   Location latitude; positive is northern hemisphere (required)</p> <p><code>-o/--longitude</code> :   Location longitude; positive is western (required)</p> <p><code>-m/--tzone</code>:</p> <p>:   Location standard meridian (required)</p> <p><code>-u/--altitude</code>:</p> <p>:   Location altitude in km, default = 0</p> <p><code>-i/--pmt</code>:</p> <p>:   Compute for photopic, melanopic, and solar for each of the three channels, instead of RGB.</p> <p><code>-r/--anglestep</code>:</p> <p>:   Angular resolution at which the sky is sampled, default = 3\u00b0</p> <p><code>-s/--observer</code>:</p> <p>:   Standard observer, 2\u00b0 or 10\u00b0</p> <p><code>-c/--colorspace</code>:</p> <p>:   Colorspace from which the sky is derived, choices are {radiance, sharp, adobe, rimm, 709, p3, 2020}, default=Radiance</p> <p><code>-e/--atm</code>:</p> <p>:   Atmospheric composition file. Default to use AFGL data that came with libRadtran, automatically chosen depending on location and time of year.</p> <p><code>-l/--aerosol</code>:</p> <p>:   Standard aerosol profile. This option overwrites the aerosol optical depth setting,defined below. The profile choices are: <code>{Continental_clean | Continental_average | Continental_polluted | Urban | Maritime_clean | Maritime_polluted | Maritime_tropical | Desert | Antarctic }</code>.</p> <p><code>-b/--cloudcover</code>:</p> <p>:   Cloud cover, [0, 1], 1 is complete cover. Cloud cover data can be sourced from TMY data.</p> <p><code>-d/--aod</code>:</p> <p>Aerosol optical depth, which can be sourced from TMY data.</p> <p><code>-g/--cloudprofile</code>:</p> <p>:   Cloud profile file path. Space separated file, three columns: height (km), liquid water content (LWC) (g/m3), effective radius (R_eff) (um). Default: water clouds exist from 2-5 km in altitude with a LWC of 2.5 g/m3 and R_eff of 100 um</p> <p><code>-t/--total</code>:</p> <p>:   Compute GHI, DNI, and DHI, instead of full sky description. Handy for quick comparison against measurements.</p> <p><code>-v/--verbose</code>:</p> <p>:   Verbosity -v=Debug, -vv=Info, -vvv=Warning, -vvvv=Error, -vvvvv=Critical, default=Warning</p>"},{"location":"manual/gencolorsky/#examples","title":"Examples","text":"<p>Compute direct normal, diffuse horizontal, and global horizontal irradiance in solar spectrum for 2022-06-21 10:00 in Berkeley CA USA, with clear sky and continental_average aerosol profile:</p> <pre><code>gencolorsky 2022 6 21 10 0 -a 37.7 -o 122.2 -m 120 -l continental_average -t\n    DNI: 864.40 W/m2; DHI: 124.47 W/m2; GHI: 862.96 W/m2\n</code></pre> <p>Compute RGB sky for 2022-12-21 16:30 in Berkeley, CA, USA, with .2 cloud cover and .3 aerosol optical depth:</p> <pre><code>gencolorsky 2022 12 21 16 30 -a 37.7 -o 122.2 -m 120 -b .2 -d .3\n</code></pre> <p>Compute photopic, melanopic, and solar for each of the three-channel for the same sky:</p> <pre><code>gencolorsky 2022 12 21 16 30 -a 37.7 -o 122.2 -m 120 -b .2 -d .3 -i\n</code></pre>"},{"location":"manual/gen/","title":"Gen","text":"<p><pre><code>gen [-h] [-v] &lt;command&gt; [options]\n</code></pre> The <code>gen</code> command-line program consists of a host of commands that do the actual work. As the name suggests, <code>gen</code> generates things. Specifically, it can be used to generate a sensor grid, glazing description, a side-lit room model, and various types of matrices. Verbosity, the amount of information printed to your console,  can be adjusted by using the <code>-v</code> option, where <code>-v=debug; -vv=info; -vvv=warning; -vvvv=critical</code>.  By default, only warning information is displayed. Instead  of display information onto the terminal, all logging information  can also be redirected as standard error into a file.  Information regarding how to run mrad and its sub-command can be display on your terminal by giving <code>-h/--help</code> options.</p> <p><pre><code>gen -h\n</code></pre> or <pre><code>gen &lt;command&gt; -h\n</code></pre> or <pre><code>gen &lt;command&gt; &lt;sub-command&gt; -h\n</code></pre></p>"},{"location":"manual/gen/#commands","title":"Commands","text":"<ul> <li>glaze</li> <li>grid</li> <li>matrix</li> <li>room</li> </ul>"},{"location":"manual/gen/glaze/","title":"gen glaze","text":"<p><pre><code>gen glaze [-h] [-v] &lt;command&gt; [options]\n</code></pre> <code>gen glaze</code> command can be used to generate a Radiance material definition  from either a IGSDB JSON file or an LBNL Optics file. <code>glaze</code> can be used to generate a single or a double-pane glazing system.</p>"},{"location":"manual/gen/glaze/#options","title":"Options","text":"<p><code>-x/--optics</code> :   LBNL Optics file path[s]. Either optics files or IGSDB files (see below) is required.</p> <p><code>-d/--igsdb</code> :   IGSDB JSON file path[s]. Either optics files (see above) or IGSDB files are required.</p> <p><code>-c/--cspace</code>:</p> <p>:   Color space (color primaries) (default: radiance)</p> <p><code>-s/--observer</code>:</p> <p>:   CIE Observer 2\u00b0 or 10\u00b0 (default: 2)</p>"},{"location":"manual/gen/glaze/#example","title":"Example","text":"<p>Generate a single-pane system using a IGSDB JSON file: <pre><code>gen glaze -d igsdb_product_23000.json\n    void BRTDfunc VNE-63_on_Pure_Mid_Iron\n    10\n        sr_clear_r sr_clear_g sr_clear_b \n        st_clear_r st_clear_g st_clear_b \n        0 0 0 glaze1.cal\n    0\n    19\n        0 0 0 \n        0 0 0 \n        0 0 0 -1 \n        0.094 0.07 0.03 \n        0.101 0.043 0.021 \n        1.102 0.593 0.246\n</code></pre> To generate a double-pane glazing system using two JSON files downloaded  from IGSDB, using the default color primaries and CIE observer, <pre><code>gen glaze -d 82378.json 43203.json\n    void BRTDfunc VNE-63_on_Pure_Mid_Iron+VE-2M_on_Pure_Mid_Iron\n    10 \n        if(Rdot,cr(fr(0.062),ft(1.310),fr(0.101)),cr(fr(0.094),ft(1.102),fr(0.070))) \n        if(Rdot,cr(fr(0.035),ft(0.662),fr(0.043)),cr(fr(0.070),ft(0.593),fr(0.041))) \n        if(Rdot,cr(fr(0.016),ft(0.277),fr(0.021)),cr(fr(0.030),ft(0.246),fr(0.017))) \n        ft(1.310)*ft(1.102) \n        ft(0.662)*ft(0.593) \n        ft(0.277)*ft(0.246) \n        0 0 0 glaze2.cal\n    0\n    9\n        0 0 0\n        0 0 0\n        0 0 0\n</code></pre></p>"},{"location":"manual/gen/grid/","title":"gen grid","text":"<p><pre><code>gen grid [-h] [-v] &lt;surface&gt; &lt;spacing&gt; &lt;height&gt; [options]\n</code></pre> The <code>grid</code> command can be used to generate an equal-distance sensor grid. There are three required inputs to this command: <code>surface</code>, <code>spacing</code>, <code>height</code>,  and a grid of sensor will be generate on the surface normal side, pointing in the same direction as the surface normal. </p>"},{"location":"manual/gen/grid/#options","title":"Options","text":"<p><code>-op</code> :   Where the generate the sensor on the opposite side of the polygon.</p>"},{"location":"manual/gen/grid/#example","title":"Example","text":"<p>To generate a grid of sensor based on the polygon defined in the <code>floor.rad</code> file, with a spacing of 2 units and 3 units away from the surface. <pre><code>gen grid floor.rad 2 3\n    1 1.7 -2 0 0 -1\n    1 3.7 -2 0 0 -1\n    1 5.7 -2 0 0 -1\n    1 7.7 -2 0 0 -1\n    1 9.7 -2 0 0 -1\n    1 11.7 -2 0 0 -1\n    1 13.7 -2 0 0 -1\n    1 15.7 -2 0 0 -1\n    ...\n</code></pre></p>"},{"location":"manual/gen/room/","title":"gen room","text":"<p><pre><code>gen room [-h] [-v] &lt;width&gt; &lt;depth&gt; &lt;floor-floor&gt; &lt;floor-ceiling&gt; [options]\n</code></pre> This command generates a side-lit rectangular room model with <code>width</code>, <code>depth</code>,  <code>floor-floor</code>, and <code>floor-ceiling</code>. </p>"},{"location":"manual/gen/room/#options","title":"Options","text":"<p><code>-w</code> :   Window[s], starting x, z, width, height.</p> <p><code>-n</code> :   Model name</p> <p><code>-t</code></p> <p>:   Facade thickness.</p> <p><code>-r/--rotate</code> :   Rotate the room counter-clockwise</p>"},{"location":"manual/gen/room/#example","title":"Example","text":"<p>Generate a room that's 12 unit wide, 14 unit deep and 3 unit height. <pre><code>gen room 12 14 3\n</code></pre> Genearte the same room, adding two windows, each 4 unit wide and 1.5 unit in height. Viewing from outside, the lower left corner of the first window is 1 unit away from the left wall and 1 unit away from the floor. <pre><code>gen room 12 14 3 -w 1 1 4 1.5 -w 5 1 4 1.5\n</code></pre></p>"},{"location":"manual/gen/matrix/","title":"gen matrix","text":"<p><pre><code>gen matrix [-h] [-v] &lt;sub-command&gt; [options]\n</code></pre> <code>matrix</code> command consists of several sub-commands, each describe a specific type of matrix generation workflow. A matrix usually describes the flux-transport of a system, which usually has a light emitter and light receiver. Because we are  dealing with backwards ray-tracing here, in which we are sending rays from the  point-of-interests towards the light source, we will call the light emitter  receiver and light receiver sender.</p> <p>Senders are usually our point-of-interests. A sender is a grid of points if we are interested in knowing how much light those grid of points receives. A sender is a view if we are interseted in knowing the rendered image from that view. A sender is a surface is we are interseted in know how much light that surface receives.</p> <p>Receiver are usually our light sources, such as sky, sun, or any surface that can be modeled as a light emitter (e.g., windows).</p> <p>Once we defined our senders and receivers, we quickly have a handful of scenarios that  we need to handle. These scenarios are the system flux-tranport properties that came  up usually in matrix-based simulation methods. As a results, <code>matrix</code> command consists of a series of sub-commands that handles each scenario. These sub-commands are  usually in the form of a <code>sender</code>-<code>receiver</code> pair:</p>"},{"location":"manual/gen/matrix/#commands","title":"Commands","text":"<ul> <li> <p>gen matrix point-sky</p> </li> <li> <p>gen matrix view-sky</p> </li> <li> <p>gen matrix surface-sky</p> </li> <li> <p>gen matrix point-surface</p> </li> <li> <p>gen matrix view-surface</p> </li> <li> <p>gen matrix surface-surface</p> </li> <li> <p>gen matrix point-sun</p> </li> <li> <p>gen matrix view-sun</p> </li> <li> <p>gen matrix ncp</p> </li> </ul>"},{"location":"manual/gen/matrix/ncp/","title":"gen matrix ncp","text":"<p><pre><code>gen matrix ncp &lt;window_file&gt; &lt;ncp_file&gt; &lt;model_files...&gt; [options]\n</code></pre> <code>gen matrix ncp</code> genertate a matrix (or BSDF) that describeds the flux transport behavior of a non-coplanar shading system.  The sender in this command is usually a window surface and  the receiver is automatically generated that encompasses the  non-coplanar shading system. The resulting matrix can be wrapped  into a xml file and be used as a regular BSDF file.</p>"},{"location":"manual/gen/matrix/ncp/#options","title":"Options","text":"<p><code>-b/--basis</code> :   Window and receiving basis. (default: ['kf', 'kf'])</p> <p><code>-w/--wrap</code> :   Generating a final xml file? (default: False)</p>"},{"location":"manual/gen/matrix/ncp/#example","title":"Example","text":"<p>Generate a non-coplanar shading matrix (e.g. a drop-arm awning system), and wrap the matrix into a .xml file. <pre><code>$ gen matrix ncp window.rad awning.rad obj/materials.mat obj/room.rad -w\n</code></pre></p>"},{"location":"manual/gen/matrix/point_sky/","title":"gen matrix point-sky","text":"<p><pre><code>gen matrix point-sky [-h] [-v] &lt;point_file&gt; &lt;model files...&gt; [options]\n</code></pre> <code>gen matrix point-sky</code> generates the matrix for a two-phase simulation, where the sender is a grid of points (e.g., a series of workplane sensors) and the receiver is the descritized sky. By default the sky is in Reinhart sky 4-subdivision, which can be adjusted with the <code>-b/--basis</code> option.</p>"},{"location":"manual/gen/matrix/point_sky/#options","title":"Options","text":"<p><code>-b/--basis</code> :   Sky basis, can be r1, r2, r4, r6</p> <p>All <code>rtrace</code> options are recognized as well.</p>"},{"location":"manual/gen/matrix/point_sky/#example","title":"Example","text":"<p>Generate a grid to sky matrix, with a reinher subdivision 4 sky (default),  and room geometry. <pre><code>gen matrix point-sky grid.pts obj/materials.mat obj/room.rad\n</code></pre></p>"},{"location":"manual/gen/matrix/point_sun/","title":"gen matrix point-sun","text":"<p><pre><code>gen matrix point-sun &lt;point_file&gt; &lt;model_files...&gt; [options]\n</code></pre> <code>gen matrix point-sun</code> generate a point to sun matrix.  This matrix is usually the direct-sun part of the  five-phase simulation. It takes a point file as the first input, followed by the rest of the model files.</p>"},{"location":"manual/gen/matrix/point_sun/#options","title":"Options","text":"<p><code>-b/--basis</code> :   Sun basis (default: r6)</p>"},{"location":"manual/gen/matrix/point_sun/#example","title":"Example","text":"<p>Generate a point to sun matrix (e.g., direct-sun matrix) <pre><code>gen matrix point-sun grid.pts obj/materials.mat obj/room.rad\n</code></pre></p>"},{"location":"manual/gen/matrix/point_surface/","title":"gen matrix point-surface","text":"<p><pre><code>gen matrix point-surface [-h] [-v] &lt;point_file&gt; &lt;surface_file&gt; &lt;model files...&gt; [options]\n</code></pre> <code>gen matrix point-surface</code> generates a matrix that describes the  flux-transport behavior between a grid of sensor and a surface,  e.g., the view-matrix in a three-phase simulation.</p>"},{"location":"manual/gen/matrix/point_surface/#options","title":"Options","text":"<p><code>-b/--basis</code> :   Surface basis (default: kf) </p> <p><code>-f/--offset</code> :   Offset surface in its normal direction (default: 0)</p> <p>All <code>rtrace</code> options are recognized as well.</p>"},{"location":"manual/gen/matrix/point_surface/#example","title":"Example","text":"<p>Generate a point to surface matrix (e.g., view matrix) <pre><code>gen matrix point-surface window.rad obj/materials.mat obj/room.rad\n</code></pre></p>"},{"location":"manual/gen/matrix/surface_sky/","title":"gen matrix surface-sky","text":"<p><pre><code>gen matrix surface-sky [-h] [-v] &lt;surface_file&gt; &lt;model files...&gt; [options]\n</code></pre> <code>gen matrix surface-sky</code> generates a matrix that describes the flux-transport behavior  between the surface and the sky. This matrix is usually the <code>daylight matrix</code> in a three-phase simulation. This command takes in a surface object file as the first positional arguments, followed by the rest of the model files.</p>"},{"location":"manual/gen/matrix/surface_sky/#options","title":"Options","text":"<p><code>-b/--basis</code> :   Sky basis, can be r1, r2, r4, r6</p> <p><code>-f/--offset</code> :   Offset the surface in its normal direction (default: 0)</p> <p>All <code>rtrace</code> options are recognized as well.</p>"},{"location":"manual/gen/matrix/surface_sky/#example","title":"Example","text":"<p>Generate a surface to sky matrix (e.g., daylight matrix), with a specific set  of <code>rcontrib</code> options. <pre><code>gen matrix surface-sky window.rad obj/materials.mat obj/room.rad \\\n    -ab 2 -ad 64 -c 1000\n</code></pre></p>"},{"location":"manual/gen/matrix/surface_surface/","title":"gen matrix surface-surface","text":"<p><pre><code>gen matrix surface-surface [-h] [-v] &lt;sender_surface&gt; &lt;receiver_surface&gt; \\\n&lt;model files...&gt; [options]\n</code></pre> <code>gen matrix surface-surface</code> generate a matrix between two arbiturary surface[s].  This command can be used, for example, to generate a matrix describes the  flux transport behavior of a tublar daylighting device.</p>"},{"location":"manual/gen/matrix/surface_surface/#options","title":"Options","text":"<p><code>-b/--basis</code> :   Sender and receiver sampling basis (default: (kf, kf))</p> <p><code>-f/--offset</code> :   Offset the sender and receiver surface in their normal  directions (default: (0, 0))</p> <p>All <code>rtrace</code> options are recognized as well.</p>"},{"location":"manual/gen/matrix/surface_surface/#example","title":"Example","text":"<p>Generate a surface to surface matrix (e.g., for a tubular daylighting device) <pre><code>gen matrix surface-surface diffuser.rad tdd_dome.rad \\\n    obj/materials.mat obj/room.rad\n</code></pre></p>"},{"location":"manual/gen/matrix/view_sky/","title":"gen matrix view-sky","text":"<p><pre><code>gen matrix view-sky [-h] [-v] &lt;view_file&gt; &lt;model files...&gt; [options]\n</code></pre> <code>gen matrix view-sky</code> generates the matrix for a two-phase simulation, where the sender is a grid of views (e.g., a series of workplane sensors) and the receiver is the descritized sky. By default the sky is in Reinhart sky 4-subdivision, which can be adjusted with the <code>-b/--basis</code> option.</p>"},{"location":"manual/gen/matrix/view_sky/#options","title":"Options","text":"<p><code>-b/--basis</code> :   Sky basis, can be r1, r2, r4, r6</p> <p><code>-r/--resolu</code> :   Image resolution (default: 800)</p> <p>All <code>rtrace</code> options are recognized as well.</p>"},{"location":"manual/gen/matrix/view_sky/#example","title":"Example","text":"<p>Generate a view to sky matrix (rendering), with a reinhart subdivision 1 sky. <pre><code>gen matrix view-sky view1.vf obj/materials.mat obj/room.rad -b r1\n</code></pre></p>"},{"location":"manual/gen/matrix/view_sun/","title":"gen matrix view-sun","text":"<p><pre><code>gen matrix view-sun [-h] [-v] &lt;view_file&gt; &lt;model_files...&gt; [options]\n</code></pre> <code>gen matrix view-sun</code> generate a view to sun matrix. This matrix is  usually the direct-sun part of the five-phase simulation.</p>"},{"location":"manual/gen/matrix/view_sun/#options","title":"Options","text":"<p><code>-b/--basis</code> :   Sun basis (default: r6)</p> <p><code>-w/--window</code> :   Window file path[s]. (default: None)</p> <p><code>-s/--smx_path</code> :   Sky matrix file path. (default: None)</p> <p><code>-r/--resolu</code> :   Image resultion (default: 512x512)</p>"},{"location":"manual/gen/matrix/view_sun/#example","title":"Example","text":"<p>Generate a view to sun matrix (e.g., image-based direct-sun matrix), with  sun-culling based on window normals and oakland annual sky matrix. <pre><code>gen matrix view-sun view1.vf obj/materials.mat obj/room.rad \\\n    -w window.rad -s oakland.smx\n</code></pre></p>"},{"location":"manual/gen/matrix/view_surface/","title":"gen matrix view-surface","text":"<p><pre><code>gen matrix view-surface [-h] [-v] &lt;view_file&gt; &lt;model files...&gt; [options]\n</code></pre> <code>gen matrix view-surface</code> generates a similar view matrix but with a view as a sender.</p>"},{"location":"manual/gen/matrix/view_surface/#options","title":"Options","text":"<p><code>-b/--basis</code> :   Surface basis, default: kf</p> <p><code>-r/--resolu</code> :   Image resolution (default: 800)</p> <p><code>-f/--offset</code> :   Offset surface in its normal direction (default: 0)</p> <p>All <code>rtrace</code> options are recognized as well.</p>"},{"location":"manual/gen/matrix/view_surface/#example","title":"Example","text":"<p>Generate a view to surface matrix (e.g., image-based view matrix) <pre><code>$ gen matrix view-surface window.rad obj/materials.mat obj/room.rad\n</code></pre></p>"},{"location":"manual/mrad/","title":"mrad","text":"<p><pre><code>mrad [-h] [-v] &lt;command&gt; [options]\n</code></pre> You can complete an entire matrix-based simulation using the <code>mrad</code> program. In general there are two steps:</p> <ol> <li>Configure your model in the form of a configuration file (.cfg)</li> <li>Feed the configuration file to <code>mrad</code> for a completly automated simulation. </li> </ol> <p>A configuration file can be generated using the <code>init</code> subcommand (see blow). It also can be programmtically generated or even manually typed in. Details of the configuration files are described below.</p>"},{"location":"manual/mrad/#commands","title":"Commands","text":"<ul> <li>mrad init</li> <li>mrad run</li> </ul>"},{"location":"manual/mrad/#verbosity-setting","title":"Verbosity setting","text":"<p>Verbosity, the amount of information printed to your terminal, can be adjusted by using the <code>-v</code> option. <code>-v</code> will display the most detailed information and <code>-vvvv</code> is effectively the silent mode. By default, only warning information is displayed. Instead of display information onto the terminal, all logging information can also be redirected as standard error into a file.</p> <pre><code>-v = debug\n-vv = info\n-vvv = warning (default)\n-vvvv = critical\n</code></pre>"},{"location":"manual/mrad/#display-help-message","title":"Display help message","text":"<p>Information regarding how to run mrad and its sub-command can be display on your terminal by giving <code>-h/--help</code> options.</p> <p><pre><code>$ mrad -h\n</code></pre> or <pre><code>$ mrad &lt;command&gt; -h\n</code></pre></p>"},{"location":"manual/mrad/#configuration","title":"Configuration","text":"<p>A configuration stores input data and file paths needed to carry out an entire simulation workflow. A configuration file (.cfg) can be typed in manually, programatically generated, or generated using the init command from the project root directory. The easiest way to generate template config file is to use <code>mrad init</code> command. To start with, the <code>init</code> command needs minimum a weather file path or a epw file path. </p> <p>A configuration file consists of four sections:  <code>SimControl</code>, <code>Site</code>, <code>Model</code>, and <code>RaySenders</code>.</p>"},{"location":"manual/mrad/#simcontrol","title":"SimControl","text":"<p>These are the options availble under this section:</p> <p><code>vmx_basis</code>: :   view matrix basis.</p> <p><code>vmx_opt</code>: :   view matrix simulation options.</p> <p><code>dmx_opt</code>: :   view matrix basis.</p> <p><code>fmx_basis</code>: :   Facade matrix basis, basis used for generate non-coplanar matrices</p> <p><code>smx_basis</code>: :   Sky matrix basis, which defines how fine to discretize the sky. Usually r1 or r4 for Tregenza or Reinhart Sky with 4 subdivisions.</p> <p><code>dsmx_opt</code>: :   two-phase method matrix option.</p> <p><code>cdsmx_opt</code>: :   Direct-sun coefficient matrices options.</p> <p><code>ray_count</code>: :   Number of rays per sample.</p> <p><code>separate_direct</code>: :   Whether to do a separate direct sun calculation. Turn this on to use five-phase method.</p> <p><code>nprocess</code>: :   Number of processors to use. This only works on Linux and MacOS.</p> <p><code>overwrite</code>: :   Whether to overwrite existing a matrices files.</p>"},{"location":"manual/mrad/#site","title":"Site","text":"<p><code>wea_path</code>: :   wea file path</p> <p><code>epw_path</code>: :   epw file path</p> <p><code>start_hour</code>: :   Filter out hours in the weather files before this hour.</p> <p><code>end_hour</code>: :   Filter out hours in the weather files after this hour.</p> <p><code>daylight_hours_only</code>: :   Filter out non-daylight ours based on frads intern solar angle calculation.</p> <p><code>orientation</code>: :   Set the model orientation.</p>"},{"location":"manual/mrad/#model","title":"Model","text":"<p><code>material</code>: :   Material file paths. These files only contain material definitions</p> <p><code>scene</code>: :   Object file paths. These files can include window files. If so, we will do two-phase simulation.</p> <p><code>windows</code>: :   Window file paths. Each file contains a window group.</p> <p><code>window_xml</code>:</p> <p><code>window_cfs</code>:</p>"},{"location":"manual/mrad/#raysenders","title":"RaySenders","text":"<p><code>grid_surface</code>: :   surface geometry file (usually .rad) containing the surface polygon from which the grid will be based on.</p> <p><code>grid_spacing</code>: :   Grid spacing in the model unit.</p> <p><code>grid_height</code>:  :   Grid height from the grid surface in the model unit.</p> <p><code>view</code>: :   A view for rendering. This can be view describtion string or a view file defined as <code>-vf view_file.vf</code>.</p>"},{"location":"manual/mrad/#default-configuration","title":"Default configuration","text":"<p>The default configuration setting (<code>mrad_default.cfg</code>) can be found inside the data directory. This default setting is loaded with both <code>init</code> and <code>run</code> command. So any options that is not set with the user defined configuration file will be set  according to the default configuration.</p> <p>The default configurations are:</p> <pre><code>[DEFAULT]\nvmx_basis = kf\nvmx_opt = -ab 6 -ad 4096 -lw 0.0001\nfmx_basis = kf\nsmx_basis = r4\ndmx_opt = -ab 2 -ad 128 -c 5000\ndsmx_opt = -ab 8 -ad 4096 -lw 0.0001 -lr 8\ncdsmx_opt = -ab 1 -dj 0 -st 0\ncdsmx_basis = r6\nray_count = 1\nnprocess = 1\nseparate_direct = False\noverwrite = False\nstart_hour = 0\nend_hour = 0\ndaylight_hours_only = True\noverwrite = True\n</code></pre>"},{"location":"manual/mrad/init/","title":"mrad init","text":"<p><pre><code>mrad init {-a wea_path | -e epw_path} [-n model_name]\n    [-o object [object ...]] [-m material [material ...]]\n    [-w window [window ...]] [-x xmls [xmls ...]]\n    [-g surface_path spacing height]\n</code></pre> The <code>init</code> command can be used to initiate a mrad configuration file. <code>init</code> command provide a series of option to select files and define the model setup. Either a <code>.wea</code> or <code>.epw</code> file path need to be provided for <code>init</code> to run (described below). You will also need to define where are objects and material files. Although <code>init</code> doesn't require specifying grid of view files, you will need to define at least one of these, by manually typing in the configuration file, in order for <code>mrad</code> to carry out the actual simulation.</p>"},{"location":"manual/mrad/init/#options","title":"Options","text":"<p><code>-a/--wea_path</code>  :   WEA file path, which can be generated using <code>epw2wea</code> program,  or generated using script. Some weather file site also provide  wea file, such as Climate.OneBuilding.org.  This option and <code>-e/--epw_path</code> option are mutually exclusive,  and one of which is required by the <code>init</code> command.</p> <p><code>-e/--epw_path</code> :   EnergyPlusWeather (EPW) file path.  Can found at EnergyPlus website and  Climate.OneBuilding.org.  This option and <code>-a/--wea_path</code> option are mutually exclusive,  and one of which is required by the <code>init</code> command.</p> <p><code>-n/--name</code> :   Give your model a name. This name will be part of the file name of the results files. If you don't give one, the name of the configuration file will be used.</p> <p><code>-o/--object</code> :   Object file path[s], usually with a .rad extension.  You can use wildcard file matching, such as <code>-o Objects/*.rad</code>, which will load  in all files that has a <code>.rad</code> file extension within the <code>Objects</code> directory.</p> <p><code>-m/--material</code> :   material file path[s], usually with a .mat extension.  You can use wildcard file matching, such as <code>-o Objects/*.mat</code>, which will load in  all files that has a <code>.mat</code> file extension within the <code>Objects</code> directory.  This implies that you will need to separate out your material definitions  from the rest of your geometry definitions. In other words,  these files should only contain material definitions.</p> <p><code>-w/--window</code> :   Window file path[s], usually with a .rad extension. You can use wildcard, such  as <code>-o Objects/window*.rad</code>, which will load in all files that starts with the  word <code>window</code> and has a <code>.rad</code> file extension within the <code>Objects</code> directory.  This implies that if you intent to have special treatments for different windows,  e.g., swap different Window BSDF to compare performance, you will need to  separate out the windows geometry definition from the rest of the model.  If you intent to have different window groups, they need to also be grouped  by files.</p> <p><code>-x/--xmls</code> :   BSDf file path[s], usually with a .xml extension. You can use wildcard, such as <code>-o Resources/*.xml</code>, which will load in all files that has a <code>.xml</code> file extension within the <code>Objects</code> directory. You will need to define <code>.xml</code> files with a one-to-one mapping to the window files described above. This implies that the window geometry within a window file will have the same BSDF treatment as defined with this option.</p> <p><code>-g/--grid</code> :   This option takes in three values: grid surface file path, grid spacing, and grid height.  Grid surface file path is the file that contains a surface from which the grid will be  constructed from. In most cases, this is the floor. Grid spacing and height are in the  same unit that the model is using.  A example us of this option can be: <code>-g Objects/floor.rad 2 2.5</code>, which will define  a 2x2 grid based on the <code>floor.rad</code> and 2.5 unit distance away from <code>floor.rad</code>.</p>"},{"location":"manual/mrad/init/#example","title":"Example","text":"<p>Here is an <code>init</code> example specifying an .epw file, material, objects and window files.</p> <pre><code>mrad init -e ./Resources/USA_CA_Oakland.Intl.AP.724930_TMY3.epw -m Objects/material.mat \n    -o Objects/wall.rad Objects/ceiling.rad Objects/floor.rad \n    -w Objects/upper_glass.rad Objects/lower_glass.rad\n</code></pre> <p>A <code>default.cfg</code> file is generated as shown below.  Notice that SimControl and RaySender sectons are empty. You can configure SimControl as needed.  Note that you will need to specify something in the RaySender section for simulation to run. </p> <pre><code>[SimControl]\n\n[Site]\nepw_path = Resources/USA_CA_Oakland.Intl.AP.724930_TMY3.epw\n\n[Model]\nname = default\nscene = Objects/ceiling.rad\n    Objects/walls.rad\n    Objects/floor.rad\nmaterial = Objects/materials.mat\nwindow_paths = Objects/upper_glass.rad\n    Objects/lower_glass.rad\n\n[RaySender]\n</code></pre>"},{"location":"manual/mrad/run/","title":"mrad run","text":"<pre><code>mrad run [cfg_path]\n</code></pre> <p>Once we have a viable configuration file, we can use the <code>run</code> command to start the simulation. Once started, <code>mrad</code> will generate a <code>Matrices</code> and a <code>Results</code> directory at the current working directory. All of the essential matrix files will be stored inside the <code>Matrices</code> folders. Intermediate matrix files will be stored inside the system <code>temp</code> directory and removed after the simulation. All results will be saved to the <code>Results</code> directory.</p> <p>The output with <code>-vv</code> verbosity setting is similar to the following: <pre><code>...\n21-04-20 22:10:44 - frads.methods - INFO - Converting EPW to a .wea file\n21-04-20 22:10:44 - frads.methods - Generating sku/sun matrix using command\n21-04-20 22:10:44 - frads.methods - gendaymtx -of -m 4 /Users/taoning/Resources/USA_CA_Oakland.Intl.AP.724930_TMY3.wea\n21-04-20 22:10:46 - frads.cli - INFO - Using two-phase method\n21-04-20 22:10:46 - frads.methods - INFO - Computing for 2-phase sensor point matrices...\n21-04-20 22:10:46 - frads.methods - INFO - Computing for image-based 2-phase matrices...\n21-04-20 22:10:46 - frads.methods - INFO - Computing for 2-phase sensor grid results.\n21-04-20 22:10:50 - frads.methods - INFO - Computing for 2-phase image-based results\n</code></pre></p>"},{"location":"ref/","title":"Reference","text":"<p>This reference guide contains a detailed description of the <code>frads</code> API. It describes how the functions and methods work and which parameter can be used. It assumes that you have an understanding of the key concepts.</p> <ol> <li>Color</li> <li>Parsers</li> <li>Sky</li> <li>Data types and containers</li> <li>Geometry</li> <li>Utility</li> <li>Matrix</li> </ol>"},{"location":"ref/#frads.color","title":"<code>frads.color</code>","text":"<p>This module contains all color and spectral-related functionalities.</p>"},{"location":"ref/#frads.color.get_conversion_matrix","title":"<code>get_conversion_matrix(prims, reverse=False)</code>","text":"<p>Get CIE conversion matrix based on color primaries.</p> <p>Parameters:</p> Name Type Description Default <code>prims</code> <code>ColorPrimaries</code> <p>Color space color primaries</p> required <code>reverse</code> <code>bool</code> <p>get RGB to XYZ conversion matrix instead</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple</code> <p>The conversion matrix coefficients in a 1-dimensional tuple.</p>"},{"location":"ref/#frads.color.get_interpolated_cie_xyz","title":"<code>get_interpolated_cie_xyz(inp_wvl, observer)</code>","text":"<p>Load CIE tristimulus data according to input wavelength. Also load melanopic action spectra data as well.</p> <p>Parameters:</p> Name Type Description Default <code>inp_wvl</code> <code>Sequence[Union[float, int]]</code> <p>a list of input wavelength in nm</p> required <code>observer</code> <code>str</code> <p>2\u00b0 or 10\u00b0 observer for the colar matching function.</p> required <p>Returns:</p> Type Description <code>List[tuple]</code> <p>CIE-x</p> <code>List[tuple]</code> <p>CIE-y</p> <code>List[tuple]</code> <p>CIE-z</p> <code>List[tuple]</code> <p>Melanopic action spectra</p> <code>List[tuple]</code> <p>Index of input wavelength corresponding to available tristimulus data</p>"},{"location":"ref/#frads.color.get_interpolated_mlnp","title":"<code>get_interpolated_mlnp(inp_wvl)</code>","text":"<p>Load CIE tristimulus data according to input wavelength. Also load melanopic action spectra data as well.</p> <p>Parameters:</p> Name Type Description Default <code>inp_wvl</code> <code>Sequence[Union[float, int]]</code> <p>a list of input wavelength in nm</p> required <p>Returns:</p> Type Description <code>List[float]</code> <p>Melanopic action spectra</p>"},{"location":"ref/#frads.color.rgb2xyz","title":"<code>rgb2xyz(red, green, blue, coeffs)</code>","text":"<p>Convert RGB to CIE XYZ.</p> <p>Parameters:</p> Name Type Description Default <code>red</code> <code>float</code> <p>red</p> required <code>green</code> <code>float</code> <p>green</p> required <code>blue</code> <code>float</code> <p>blue</p> required <code>coeffs</code> <code>tuple</code> <p>coversion matrix.</p> required <p>Returns:</p> Type Description <code>Tuple[float, float, float]</code> <p>CIE X, Y, Z.</p> Raise <p>ValueError with invalid coeffs.</p>"},{"location":"ref/#frads.color.spec2xyz","title":"<code>spec2xyz(cie_xyz_bar, spec, wvl_range, emis=False)</code>","text":"<p>Convert spectral data to CIE XYZ.</p> <p>Parameters:</p> Name Type Description Default <code>cie_xyz_bar</code> <p>CIE color matching function.</p> required <code>spec</code> <code>list</code> <p>input spectral data as a dictionary sorted by wavelenth as key.</p> required <code>emis</code> <code>bool</code> <p>flag whether the input data is emissive in nature.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple</code> <p>CIE X, Y, Z</p> Note <p>Assuming input wavelength is a subset of the CIE ones</p>"},{"location":"ref/#frads.color.xyz2rgb","title":"<code>xyz2rgb(cie_x, cie_y, cie_z, coeffs)</code>","text":"<p>Convert CIE XYZ to RGB.</p> <p>Parameters:</p> Name Type Description Default <code>cie_x</code> <code>float</code> <p>cie_x</p> required <code>cie_y</code> <code>float</code> <p>cie_y</p> required <code>cie_z</code> <code>float</code> <p>cie_z</p> required <code>coeffs</code> <code>tuple</code> <p>conversion matrix</p> required <p>Returns:</p> Type Description <code>Tuple[float, float, float]</code> <p>Red, Green, Blue</p> Raise <p>ValueError for invalid coeffs.</p>"},{"location":"ref/#frads.color.xyz2xy","title":"<code>xyz2xy(cie_x, cie_y, cie_z)</code>","text":"<p>Convert CIE XYZ to xy chromaticity.</p> <p>Parameters:</p> Name Type Description Default <code>cie_x</code> <code>float</code> <p>CIE X</p> required <code>cie_y</code> <code>float</code> <p>CIE Y</p> required <code>cie_z</code> <code>float</code> <p>CIE Z</p> required <p>Returns:</p> Type Description <code>float</code> <p>x chromoticity</p> <code>float</code> <p>y chromoticity</p>"},{"location":"ref/#frads.parsers","title":"<code>frads.parsers</code>","text":"<p>This module contains all data parsing routines.</p>"},{"location":"ref/#frads.parsers.TensorTree","title":"<code>TensorTree</code>","text":"<p>The tensor tree object. Anisotropic tensor tree has should have 16 lists</p> <p>Attributes:</p> Name Type Description <code>parsed</code> <p>parsed tensor tree object)</p> <code>depth</code> <p>number of tree levels</p>"},{"location":"ref/#frads.parsers.TensorTree.get_branch_index","title":"<code>get_branch_index(xp, yp)</code>","text":"<p>Gets a set of index.</p>"},{"location":"ref/#frads.parsers.TensorTree.lookup","title":"<code>lookup(xp, yp)</code>","text":"<p>Traverses a parsed tensor tree (a nexted list) given a input position.</p>"},{"location":"ref/#frads.parsers.TensorTree.traverse","title":"<code>traverse(quad, xp, yp, n=1)</code>","text":"<p>Traverse a quadrant.</p>"},{"location":"ref/#frads.parsers.get_nested_list_levels","title":"<code>get_nested_list_levels(nested_list)</code>","text":"<p>Calculate the number of levels given a nested list.</p>"},{"location":"ref/#frads.parsers.get_rcontrib_options_args","title":"<code>get_rcontrib_options_args(parser)</code>","text":"<p>Add rcontrib specific options to a parser.</p>"},{"location":"ref/#frads.parsers.get_rtrace_options_args","title":"<code>get_rtrace_options_args(parser)</code>","text":"<p>Add rtrace options and flags to a parser.</p>"},{"location":"ref/#frads.parsers.parse_branch","title":"<code>parse_branch(token)</code>","text":"<p>Prase tensor tree branches recursively by opening and closing curly braces.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Generator[str, None, None]</code> <p>token generator object.</p> required Return <p>children: parsed branches as nexted list</p>"},{"location":"ref/#frads.parsers.parse_epw","title":"<code>parse_epw(epw_str)</code>","text":"<p>Parse epw file and return wea header and data.</p>"},{"location":"ref/#frads.parsers.parse_idf","title":"<code>parse_idf(content)</code>","text":"<p>Parse an IDF file into a dictionary.</p>"},{"location":"ref/#frads.parsers.parse_igsdb_json","title":"<code>parse_igsdb_json(json_obj)</code>","text":"<p>Parse a JSON file from IGSDB.</p>"},{"location":"ref/#frads.parsers.parse_mrad_config","title":"<code>parse_mrad_config(cfg_path)</code>","text":"<p>Parse mrad configuration file.</p>"},{"location":"ref/#frads.parsers.parse_opt","title":"<code>parse_opt(opt_str)</code>","text":"<p>Parsing option string into a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>opt_str</code> <code>str</code> <p>rtrace option parameters as a string</p> required <p>Returns:</p> Type Description <code>dict</code> <p>An option dictionary</p>"},{"location":"ref/#frads.parsers.parse_optics","title":"<code>parse_optics(fpath)</code>","text":"<p>Read and parse an optics file.</p>"},{"location":"ref/#frads.parsers.parse_polygon","title":"<code>parse_polygon(real_args)</code>","text":"<p>Parse real arguments to polygon.</p> <p>Parameters:</p> Name Type Description Default <code>primitive</code> <p>a dictionary object containing a primitive</p> required <p>Returns:</p> Type Description <code>geom.Polygon</code> <p>modified primitive</p>"},{"location":"ref/#frads.parsers.parse_primitive","title":"<code>parse_primitive(lines)</code>","text":"<p>Parse Radiance primitives inside a file path into a list of dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list</code> <p>list of lines as strings</p> required <p>Returns:</p> Type Description <code>List[Primitive]</code> <p>list of primitives as dictionaries</p> Notes <p>Dropping support for alias type</p>"},{"location":"ref/#frads.parsers.parse_rad_header","title":"<code>parse_rad_header(header_str)</code>","text":"<p>Parse a Radiance matrix file header.</p> <p>Parameters:</p> Name Type Description Default <code>header_str(str)</code> <p>header as string</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple contain nrow, ncol, ncomp, datatype</p>"},{"location":"ref/#frads.parsers.parse_ttree","title":"<code>parse_ttree(data_str)</code>","text":"<p>Parse a tensor tree.</p> <p>Parameters:</p> Name Type Description Default <code>data_str</code> <code>str</code> <p>input data string</p> required <p>Returns:</p> Type Description <code>list</code> <p>A nested list that is the tree</p>"},{"location":"ref/#frads.parsers.parse_vu","title":"<code>parse_vu(vu_str)</code>","text":"<p>Parse view string into a View object.</p> <p>Parameters:</p> Name Type Description Default <code>vu_str</code> <code>str</code> <p>view parameters as a string</p> required <p>Returns:</p> Type Description <code>View</code> <p>A view object</p>"},{"location":"ref/#frads.parsers.parse_wea","title":"<code>parse_wea(wea_str)</code>","text":"<p>Parse a wea file in its entirety.</p>"},{"location":"ref/#frads.parsers.tokenize","title":"<code>tokenize(inp)</code>","text":"<p>Generator for tokenizing a string that is seperated by a space or a comma.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str</code> <p>input string</p> required <p>Yields:</p> Type Description <code>Generator[str, None, None]</code> <p>next token</p>"},{"location":"ref/#frads.sky","title":"<code>frads.sky</code>","text":"<p>Routines for generating sky models</p>"},{"location":"ref/#frads.sky.basis_glow","title":"<code>basis_glow(sky_basis)</code>","text":"<p>Generate a set of regular sky and ground glow primitives string.</p> <p>Parameters:</p> Name Type Description Default <code>sky_basis(str)</code> <p>sky sampling basis, e.g. r1, r4</p> required <p>Returns:</p> Type Description <code>str</code> <p>ground and sky glow string, usually used for rfluxmtx calls.</p>"},{"location":"ref/#frads.sky.check_sun_above_horizon","title":"<code>check_sun_above_horizon(data, metadata)</code>","text":"<p>Remove non-daylight hour entries.</p>"},{"location":"ref/#frads.sky.filter_data_by_direct_sun","title":"<code>filter_data_by_direct_sun(data, meta, window_normal=None)</code>","text":"<p>Remove wea data entries with zero solar luminance according to Perez All-Weather sky model. If window normal supplied, eliminate entries not seen by window. Window field of view is 176 deg with 2 deg tolerance on each side.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[WeaData]</code> <p>Sequence[WeaData],</p> required <code>meta</code> <code>WeaMetaData</code> <p>WeaMetaData,</p> required <code>window_normal</code> <code>Optional[Sequence[geom.Vector]]</code> <p>Optional[Sequence[geom.Vector]] = None,</p> <code>None</code> <p>Returns:</p> Name Type Description <code>data</code> <code>List[WeaData]</code>"},{"location":"ref/#frads.sky.filter_data_with_zero_dni","title":"<code>filter_data_with_zero_dni(data)</code>","text":"<p>Filter out data entries with zero direct normal irradiance.</p>"},{"location":"ref/#frads.sky.filter_wea","title":"<code>filter_wea(wea_data, meta_data, start_hour=None, end_hour=None, daylight_hours_only=False, remove_zero=False, window_normals=None)</code>","text":"<p>Obtain and prepare weather file data.</p> <p>Parameters:</p> Name Type Description Default <code>wea_data(List[WeaData])</code> <p>A list of WeaData.</p> required <code>meta_data(WeaMetaData)</code> <p>A instance of WeaMetaData object.</p> required <code>start_hour(float,</code> <code>optional</code> <p>Filter out wea data before this hour.</p> required <code>end_hour(float,</code> <code>optional</code> <p>Filter out wea data after this hour.</p> required <code>daylight_hours_only(bool,</code> <code>optional</code> <p>Filter out wea data below horizon.</p> required <code>remove_zero(bool,</code> <code>optional</code> <p>Filter out wea data with zero DNI.</p> required <code>window_normals(List[geom.Vector],</code> <code>optional</code> <p>Filter out wea data with direct sun not seen by these window normals.</p> required <p>Returns:</p> Name Type Description <code>wea_data</code> <code>List[WeaData]</code> <p>Filterd list of wea data</p> <code>datetime_stamps</code> <code>list</code> <p>Remaining datetime stamps</p>"},{"location":"ref/#frads.sky.gen_sun_source_culled","title":"<code>gen_sun_source_culled(mf, smx_path=None, window_normals=None)</code>","text":"<p>Generate a culled set of sun sources based on either window orientation and/or climate-based sky matrix. The reduced set of sun sources will significantly speed up the direct-sun matrix generation.</p> <p>Parameters:</p> Name Type Description Default <code>mf(int)</code> <p>multiplication factor, usually 1, 2, or 4.</p> required <code>smx_path(str)</code> <p>Optional, sky matrix path, usually the output of gendaymtx</p> required <code>window_normals(str)</code> <p>Optional, window normals</p> required <p>Returns:</p> Type Description <code>str</code> <p>A tuple of culled set of sun light and source primitive string,</p> <code>str</code> <p>corresponding modifier strings, and the full set of modifier string.</p>"},{"location":"ref/#frads.sky.gen_sun_source_full","title":"<code>gen_sun_source_full(mf)</code>","text":"<p>Generate a full set of sun light sources according to Reinhart basis.</p> <p>Parameters:</p> Name Type Description Default <code>mf(int)</code> <p>multiplication factor, usually 1, 2, or 4.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A tuple of full set of sun light and source primitive string</p> <code>str</code> <p>and associated modifier string.</p>"},{"location":"ref/#frads.sky.gendaylit_cmd","title":"<code>gendaylit_cmd(month, day, hours, lat, lon, tzone, year=None, grefl=None, dir_norm_ir=None, dif_hor_ir=None, dir_hor_ir=None, dir_norm_il=None, dif_hor_il=None, solar=False)</code>","text":"<p>Get a gendaylit command as a list.</p>"},{"location":"ref/#frads.sky.gendaymtx","title":"<code>gendaymtx(out, mf, data=None, meta=None, wpath=None, direct=False, solar=False, onesun=False, rotate=None, binary=False)</code>","text":"<p>Call gendaymtx to generate a sky/sun matrix and write results to out.  It takes either a .wea file path or wea data and metadata (defined in frads.types). If both are provided, .wea file path will be used.</p> <p>Parameters:</p> Name Type Description Default <code>out(str</code> <code>or pathlib.Path</code> <p>outpath file path</p> required <code>mf(int)</code> <p>multiplication factor</p> required <code>data(Sequence[WeaData],</code> <code>optional</code> <p>A sequence of WeaData.</p> required <code>meta(WeaMetaData,</code> <code>optional</code> <p>A instance of WeaMetaData object.</p> required <code>wpath(Path,</code> <code>optional</code> <p>.wea file path.</p> required <code>direct(bool,</code> <code>optional</code> <p>Whether to generate sun-only sky matrix.</p> required <code>solar(bool,</code> <code>optional</code> <p>Whether to generate sky matrix if solar spectrum.</p> required <code>onesun(bool,</code> <code>optional</code> <p>Whether to generate single sun matrix (five-phase).</p> required <code>rotate(float,</code> <code>optional</code> <p>rotate the sky counter-clock wise, looking down.</p> required <code>binary(bool,</code> <code>optional</code> <p>Whether to have outputs in single precision floats.</p> required <p>Returns:</p> Name Type Description <code>cmd</code> <code>List[str]</code> <p>the gendaymtx command called.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>An error occurs if neither a .wea path nor wea data is provided.</p>"},{"location":"ref/#frads.sky.grndglow","title":"<code>grndglow(basis='u')</code>","text":"<p>Generate a set of ground string</p> <p>Parameters:</p> Name Type Description Default <code>basis(str)</code> <p>Optional default=u</p> required <p>Returns:</p> Type Description <code>str</code> <p>A set of ground glow primitive string</p>"},{"location":"ref/#frads.sky.skyglow","title":"<code>skyglow(basis, upvect='+Y')</code>","text":"<p>Generate a set of skyglow string</p> <p>Parameters:</p> Name Type Description Default <code>basis(str)</code> <p>e.g., r1, r2, r4</p> required <code>upvect(str)</code> <p>Optional, default=+Y</p> required <p>Returns:</p> Type Description <code>str</code> <p>A set of sky glow primitive string</p>"},{"location":"ref/#frads.sky.solar_angle","title":"<code>solar_angle(lat, lon, mer, month, day, hour)</code>","text":"<p>Simplified translation from the Radiance sun.c and gensky.c code.</p>"},{"location":"ref/#frads.sky.start_end_hour","title":"<code>start_end_hour(data, sh, eh)</code>","text":"<p>Remove wea data entries outside of the start and end hour.</p>"},{"location":"ref/#frads.types","title":"<code>frads.types</code>","text":"<p>This module contains all data types used across frads. The exceptions are the Vector and Polygon class in the geom.py module.</p>"},{"location":"ref/#frads.types.Primitive","title":"<code>Primitive</code>","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Radiance Primitive.</p> <p>Attributes one-to-one mapped from Radiance.</p> <p>Attributes:</p> Name Type Description <code>modifier</code> <code>str</code> <p>modifier, which primitive modifies this one</p> <code>ptype</code> <code>str</code> <p>primitive type</p> <code>identifier</code> <code>str</code> <p>identifier, name of this primitive</p> <code>str_arg</code> <code>Sequence[str]</code> <p>string argument</p> <code>real_arg</code> <code>Sequence[Union[int, float]]</code> <p>real argument</p> <code>int_arg</code> <code>str</code> <p>integer argument, not used in Radiance (default=\"0\")</p>"},{"location":"ref/#frads.types.Sender","title":"<code>Sender</code>  <code>dataclass</code>","text":"<p>Sender object for matrix generation.</p> <p>Attributes:</p> Name Type Description <code>form</code> <code>str</code> <p>types of sender, {surface(s)|view(v)|points(p)}</p> <code>sender</code> <code>bytes</code> <p>the sender string</p> <code>xres</code> <code>Optional[int]</code> <p>sender x dimension</p> <code>yres</code> <code>Optional[int]</code> <p>sender y dimension</p>"},{"location":"ref/#frads.types.Receiver","title":"<code>Receiver</code>  <code>dataclass</code>","text":"<p>Receiver object for matrix generation.</p> <p>Attributes:</p> Name Type Description <code>receiver</code> <code>str</code> <p>receiver string which can be appended to one another</p> <code>basis</code> <code>str</code> <p>receiver basis, usually kf, r4, r6;</p> <code>modifier</code> <code>str</code> <p>modifiers to the receiver objects;</p>"},{"location":"ref/#frads.types.PaneProperty","title":"<code>PaneProperty</code>","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Window pane property object.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>material name.</p> <code>thickness</code> <code>float</code> <p>pane thickness.</p> <code>gtype</code> <code>str</code> <p>material type.</p> <code>coated_side</code> <code>str</code> <p>coated side, front or back.</p> <code>wavelength</code> <code>List[float]</code> <p>Wavelength data.</p> <code>transmittance</code> <code>List[float]</code> <p>Transmittance data.</p> <code>reflectance_front</code> <code>List[float]</code> <p>Reflectance front data.</p> <code>reflectance_back</code> <code>List[float]</code> <p>Reflectance back data.</p>"},{"location":"ref/#frads.types.WeaMetaData","title":"<code>WeaMetaData</code>","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Weather related meta data object.</p> <p>Attributes:</p> Name Type Description <code>city</code> <code>str</code> <p>City.</p> <code>country</code> <code>str</code> <p>Country.</p> <code>latitude</code> <code>float</code> <p>Latitude.</p> <code>longitude</code> <code>float</code> <p>Longitude.</p> <code>timezone</code> <code>int</code> <p>Timezone as standard meridian.</p> <code>elevation</code> <code>float</code> <p>Site elevation (m).</p>"},{"location":"ref/#frads.types.WeaMetaData.wea_header","title":"<code>wea_header()</code>","text":"<p>Return a .wea format header.</p>"},{"location":"ref/#frads.types.WeaData","title":"<code>WeaData</code>","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Weather related data object.</p> <p>Attributes:</p> Name Type Description <code>month</code> <p>Month.</p> <code>day</code> <p>Day.</p> <code>hour</code> <p>Hour.</p> <code>minute</code> <p>Minutes.</p> <code>second</code> <p>Seconds.</p> <code>hours</code> <p>Times with minutes as fraction.</p> <code>dni</code> <code>float</code> <p>Direct normal irradiance (W/m2).</p> <code>dhi</code> <code>float</code> <p>Diffuse horizontal irradiance (W/m2).</p> <code>aod</code> <code>float</code> <p>Aeroal Optical Depth (default = 0).</p> <code>cc</code> <code>float</code> <p>Cloud cover (default = 0).</p> <code>year</code> <code>float</code> <p>default = 2000.</p>"},{"location":"ref/#frads.types.MradModel","title":"<code>MradModel</code>","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Mrad model object.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Model name</p> <code>material_path</code> <code>Path</code> <p>Material path</p> <code>window_groups</code> <code>Dict[str, List[Primitive]]</code> <p>Window primitives grouped by files</p> <code>window_normals</code> <code>List[Vector]</code> <p>Window normals</p> <code>sender_grid</code> <code>dict</code> <p>Grid ray samples mapped to grid surface name.</p> <code>sender_view</code> <code>dict</code> <p>View ray samples mapped to view name.</p> <code>views</code> <code>dict</code> <p>Mapping from View name to view properties.</p> <code>receiver_sky</code> <code>dict</code> <p>Sky as the receiver object.</p> <code>bsdf_xml</code> <code>dict</code> <p>Mapping from window groupd name to BSDF file path.</p> <code>cfs_paths</code> <code>list</code> <p>The list of files used for direct-sun coefficient calculations.</p> <code>ncp_shades</code> <code>dict</code> <p>The list of non-coplanar shading files.</p> <code>black_env_path</code> <code>Path</code> <p>Blackened environment file path.</p>"},{"location":"ref/#frads.types.MradPath","title":"<code>MradPath</code>  <code>dataclass</code>","text":"<p>This dataclass object holds all the paths during a mrad run. All attributes are initiated with default_factory set to the attribute's type, which means this object can be instantiated without any arguments and add define its attributes later.</p> <p>Attributes:</p> Name Type Description <code>pvmx</code> <code>Dict[str, Path]</code> <p>Point view matrix paths mapped to grid name.</p> <code>pvmxd</code> <code>Dict[str, Path]</code> <p>Direct only point view matrix paths mapped to grid name.</p> <code>pdsmx</code> <code>Dict[str, Path]</code> <p>Point daylight coefficient matrix file paths mapped to grid name.</p> <code>pcdsmx</code> <code>Dict[str, Path]</code> <p>Point direct-sun coefficient matrix file paths mapped to grid name.</p> <code>vvmx</code> <code>Dict[str, Path]</code> <p>View view matrix paths mapped to view name.</p> <code>vvmxd</code> <code>Dict[str, Path]</code> <p>Direct only view view matrix paths mapped to view name.</p> <code>vdsmx</code> <code>Dict[str, Path]</code> <p>View daylight coefficient matrix file paths mapped to grid name.</p> <code>vcdsmx</code> <code>Dict[str, Path]</code> <p>View direct-sun coefficient matrix file paths mapped to view name.</p> <code>vcdfmx</code> <code>Dict[str, Path]</code> <p>View direct-sun coefficient(f) matrix file paths mapped to view name.</p> <code>vcdrmx</code> <code>Dict[str, Path]</code> <p>View direct-sun coefficient(r) matrix file paths mapped to view name.</p> <code>vmap</code> <code>Dict[str, Path]</code> <p>View matrix material map mapped to view name.</p> <code>cdmap</code> <code>Dict[str, Path]</code> <p>Direct-sun matrix material map mapped to view name.</p> <code>dmx</code> <code>Dict[str, Path]</code> <p>Daylight matrix file paths mapped to window name.</p> <code>dmxd</code> <code>Dict[str, Path]</code> <p>Direct daylight matrix mapped to window name.</p> <code>smxd</code> <code>Path</code> <p>Sun-only (3-4 sun patches) sky matrix file path.</p> <code>smx</code> <code>Path</code> <p>sky matrix file path.</p> <code>smx_sun</code> <code>Path</code> <p>Sun-only (one sun patch) sky matrix file path for illuminance.</p> <code>smx_sun_img</code> <code>Path</code> <p>Sun-only (one sun pathc) sky matrix file path for rendering.</p>"},{"location":"ref/#frads.geom","title":"<code>frads.geom</code>","text":"<p>This module contains definitions of Vector and Polygon objects and other geometry related routines.</p>"},{"location":"ref/#frads.geom.Polygon","title":"<code>Polygon</code>  <code>dataclass</code>","text":"<p>3D polygon class</p> <p>Attributes:</p> Name Type Description <code>vertices(List[Vector])</code> <p>list of vertices of the polygon.</p>"},{"location":"ref/#frads.geom.Polygon.area","title":"<code>area: float</code>  <code>property</code>","text":"<p>Calculate the area of the polygon.</p>"},{"location":"ref/#frads.geom.Polygon.centroid","title":"<code>centroid: Vector</code>  <code>property</code>","text":"<p>Return the geometric center point.</p>"},{"location":"ref/#frads.geom.Polygon.extreme","title":"<code>extreme: Tuple[float, ...]</code>  <code>property</code>","text":"<p>.</p>"},{"location":"ref/#frads.geom.Polygon.normal","title":"<code>normal: Vector</code>  <code>property</code>","text":"<p>Calculate the polygon normal.</p>"},{"location":"ref/#frads.geom.Polygon.__add__","title":"<code>__add__(other)</code>","text":"<p>Merge two polygons.</p>"},{"location":"ref/#frads.geom.Polygon.__post_init__","title":"<code>__post_init__()</code>","text":"<p>.</p>"},{"location":"ref/#frads.geom.Polygon.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Polygon subtraction.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Polygon</code> <p>subtract this polygon</p> required <p>Returns:</p> Type Description <code>Polygon</code> <p>Clipped polygon (Polygon)</p>"},{"location":"ref/#frads.geom.Polygon.extrude","title":"<code>extrude(vector)</code>","text":"<p>Extrude the polygon.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>Vector</code> <p>extrude along the vector;</p> required <p>Returns:</p> Name Type Description <code>Polygon</code> <code>list</code> <p>a list of polygons;</p>"},{"location":"ref/#frads.geom.Polygon.flip","title":"<code>flip()</code>","text":"<p>Reverse the vertices order, thus reversing the normal.</p>"},{"location":"ref/#frads.geom.Polygon.move","title":"<code>move(vector)</code>","text":"<p>Return the moved polygon along a vector.</p>"},{"location":"ref/#frads.geom.Polygon.rectangle3pts","title":"<code>rectangle3pts(pt1, pt2, pt3)</code>  <code>classmethod</code>","text":"<p>.</p>"},{"location":"ref/#frads.geom.Polygon.rotate","title":"<code>rotate(vector, angle)</code>","text":"<p>.</p>"},{"location":"ref/#frads.geom.Polygon.scale","title":"<code>scale(scale_vect, center)</code>","text":"<p>Scale the polygon.</p> <p>Parameters:</p> Name Type Description Default <code>scale_vect</code> <code>Vector</code> <p>scale along x, y, z;</p> required <code>center</code> <code>Vector</code> <p>center of scaling</p> required Return <p>Scaled polygon (Polygon)</p>"},{"location":"ref/#frads.geom.Polygon.shared_pts","title":"<code>shared_pts(other)</code>","text":"<p>Return the total number of share points between two polygons.</p>"},{"location":"ref/#frads.geom.Polygon.to_list","title":"<code>to_list()</code>","text":"<p>Return a list of tuples.</p>"},{"location":"ref/#frads.geom.Polygon.to_real","title":"<code>to_real()</code>","text":"<p>Convert the vertices to real arg string format.</p>"},{"location":"ref/#frads.geom.Vector","title":"<code>Vector</code>  <code>dataclass</code>","text":"<p>3D vector class.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>x coordinate</p> <code>y</code> <code>float</code> <p>y coordinate</p> <code>z</code> <code>float</code> <p>z coordinate</p>"},{"location":"ref/#frads.geom.Vector.length","title":"<code>length: float</code>  <code>property</code>","text":"<p>Get vector distance from origin.</p>"},{"location":"ref/#frads.geom.Vector.__add__","title":"<code>__add__(other)</code>","text":"<p>Add the two vectors.</p> <p>Parameters:</p> Name Type Description Default <code>other(Vector)</code> <p>vector to add</p> required <p>Returns:</p> Type Description <code>Vector</code> <p>The added vector(Vector)</p>"},{"location":"ref/#frads.geom.Vector.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Return the dot produce between two vectors.</p>"},{"location":"ref/#frads.geom.Vector.__str__","title":"<code>__str__()</code>","text":"<p>Class string representation.</p> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the vector(str)</p>"},{"location":"ref/#frads.geom.Vector.angle_from","title":"<code>angle_from(other)</code>","text":"<p>.</p>"},{"location":"ref/#frads.geom.Vector.coplanar","title":"<code>coplanar(other1, other2)</code>","text":"<p>Test if the vector is coplanar with the other two vectors.</p>"},{"location":"ref/#frads.geom.Vector.cross","title":"<code>cross(other)</code>","text":"<p>Return the cross product of the two vectors.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Vector</code> <p>the vector to take a cross product</p> required <p>Returns:</p> Type Description <code>Vector</code> <p>The resulting vector</p>"},{"location":"ref/#frads.geom.Vector.distance_from","title":"<code>distance_from(other)</code>","text":"<p>Calculate the distance between two points.</p>"},{"location":"ref/#frads.geom.Vector.normalize","title":"<code>normalize()</code>","text":"<p>Return the unit vector.</p>"},{"location":"ref/#frads.geom.Vector.reverse","title":"<code>reverse()</code>","text":"<p>Return the reversed vector.</p>"},{"location":"ref/#frads.geom.Vector.rotate_3d","title":"<code>rotate_3d(vector, theta)</code>","text":"<p>Rotate the point around the vector theta radians.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>Vector</code> <p>rotation axis</p> required <code>theta</code> <code>float</code> <p>rotation radians</p> required <p>Returns:</p> Type Description <code>Vector</code> <p>the rotated point</p>"},{"location":"ref/#frads.geom.Vector.scale","title":"<code>scale(factor)</code>","text":"<p>Scale the vector by a scalar.</p>"},{"location":"ref/#frads.geom.Vector.spherical","title":"<code>spherical(theta, phi, r)</code>  <code>classmethod</code>","text":"<p>Construct a vector using spherical coordinates.</p>"},{"location":"ref/#frads.geom.Vector.to_list","title":"<code>to_list()</code>","text":"<p>Return a list containing the coordinates.</p>"},{"location":"ref/#frads.geom.Vector.to_sphr","title":"<code>to_sphr()</code>","text":"<p>Convert cartesian to spherical coordinates.</p>"},{"location":"ref/#frads.geom.Vector.to_tuple","title":"<code>to_tuple()</code>","text":"<p>Return a tuple containing the coordinates.</p>"},{"location":"ref/#frads.geom.convexhull","title":"<code>convexhull(points, normal)</code>","text":"<p>Convex hull on coplanar points.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list</code> <p>list of Point;</p> required <code>normal</code> <code>Vector</code> <p>plane's normal</p> required"},{"location":"ref/#frads.geom.get_polygon_limits","title":"<code>get_polygon_limits(polygon_list, offset=0.0)</code>","text":"<p>Get the x,y,z limits from a list of polygons.</p>"},{"location":"ref/#frads.geom.getbbox","title":"<code>getbbox(polygons, offset=0.0)</code>","text":"<p>Get a bounding box for a list of polygons.</p> <p>Return a list of polygon that is the orthogonal bounding box of a list of polygon.</p> <p>Parameters:</p> Name Type Description Default <code>polygons</code> <code>Sequence[Polygon]</code> <p>list of polygons</p> required <code>offset</code> <code>float</code> <p>make the box smaller or bigger</p> <code>0.0</code> <p>Returns:</p> Type Description <p>A list of polygon that is the bounding box.</p>"},{"location":"ref/#frads.geom.merge_polygon","title":"<code>merge_polygon(polygons)</code>","text":"<p>Merge polygons into a polygon using Convex Hull.</p> <p>Parameters:</p> Name Type Description Default <code>polygons</code> <code>Sequence[Polygon]</code> <p>Polygons to be merged</p> required <p>Returns:</p> Type Description <code>Polygon</code> <p>Merged polygon</p>"},{"location":"ref/#frads.geom.polygon_center","title":"<code>polygon_center(*polygons)</code>","text":"<p>Calculate the center from polygons.</p>"},{"location":"ref/#frads.utils","title":"<code>frads.utils</code>","text":"<p>This module contains all utility functions used throughout frads.</p>"},{"location":"ref/#frads.utils.angle_basis_coeff","title":"<code>angle_basis_coeff(basis)</code>","text":"<p>Calculate klems basis coefficient</p>"},{"location":"ref/#frads.utils.batch_process","title":"<code>batch_process(commands, inputs=None, opaths=None, nproc=None)</code>","text":"<p>Run commands in batches.</p> <p>Use subprocess.Popen to run commands.</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>List[List[str]]</code> <p>commands as a list of strings.</p> required <code>inputs</code> <code>Optional[List[bytes]]</code> <p>list of standard input to the commands.</p> <code>None</code> <code>opaths</code> <code>Optional[List[Path]]</code> <p>list of paths to write standard output to.</p> <code>None</code> <code>nproc</code> <code>Optional[int]</code> <p>number of commands to run in parallel at a time.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"ref/#frads.utils.bsdf2sdata","title":"<code>bsdf2sdata(bsdf)</code>","text":"<p>Covert a bsdf object into a sdata object.</p>"},{"location":"ref/#frads.utils.bsdf_prim","title":"<code>bsdf_prim(mod, ident, xmlpath, upvec, pe=False, thickness=0.0, xform=None, real_args='0')</code>","text":"<p>Create a BSDF primtive.</p>"},{"location":"ref/#frads.utils.calc_reinsrc_dir","title":"<code>calc_reinsrc_dir(mf, x1=0.5, x2=0.5)</code>","text":"<p>Calculate Reinhart/Treganza sampling directions. Direct translation of Radiance reinsrc.cal file.</p> <p>Parameters:</p> Name Type Description Default <code>mf(int)</code> <p>multiplication factor.</p> required <code>x1(float,</code> <code>optional</code> <p>bin position 1</p> required <code>x2(float,</code> <code>optional</code> <p>bin position 2</p> required <p>Returns:</p> Type Description <code>List[geom.Vector]</code> <p>A list of geom.Vector</p> <code>List[float]</code> <p>A list of solid angle associated with each vector</p>"},{"location":"ref/#frads.utils.color_plastic_prim","title":"<code>color_plastic_prim(mod, ident, refl, red, green, blue, specu, rough)</code>","text":"<p>Generate a colored plastic material.</p> <p>Parameters:</p> Name Type Description Default <code>mod(str)</code> <p>modifier to the primitive</p> required <code>ident(str)</code> <p>identifier to the primitive</p> required <code>refl</code> <code>float</code> <p>measured reflectance (0.0 - 1.0)</p> required <code>red;</code> <code>green; blue (int</code> <p>rgb values (0 - 255)</p> required <code>specu</code> <code>float</code> <p>material specularity (0.0 - 1.0)</p> required <code>rough</code> <code>float</code> <p>material roughness (0.0 - 1.0)</p> required <p>Returns:</p> Type Description <code>Primitive</code> <p>A material primtive</p>"},{"location":"ref/#frads.utils.frange_inc","title":"<code>frange_inc(start, stop, step)</code>","text":"<p>Generate increasing non-integer range.</p>"},{"location":"ref/#frads.utils.gen_blinds","title":"<code>gen_blinds(depth, width, height, spacing, angle, curve, movedown)</code>","text":"<p>Generate genblinds command for genBSDF.</p>"},{"location":"ref/#frads.utils.gen_grid","title":"<code>gen_grid(polygon, height, spacing)</code>","text":"<p>Generate a grid of points for orthogonal planar surfaces.</p> <p>Parameters:</p> Name Type Description Default <code>polygon</code> <code>geom.Polygon</code> <p>a polygon object</p> required <code>height</code> <code>float</code> <p>points' distance from the surface in its normal direction</p> required <code>spacing</code> <code>float</code> <p>distance between the grid points</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of the points as list</p>"},{"location":"ref/#frads.utils.get_flush_corner_rays_command","title":"<code>get_flush_corner_rays_command(ray_cnt, xres)</code>","text":"<p>Flush the corner rays from a fisheye view.</p> <p>Parameters:</p> Name Type Description Default <code>ray_cnt</code> <code>int</code> <p>ray count;</p> required <code>xres</code> <code>int</code> <p>resolution of the square image;</p> required <p>Returns:</p> Type Description <code>list</code> <p>Command to generate cropped rays</p>"},{"location":"ref/#frads.utils.get_glazing_primitive","title":"<code>get_glazing_primitive(panes)</code>","text":"<p>Generate a BRTDfunc to represent a glazing system.</p>"},{"location":"ref/#frads.utils.glass_prim","title":"<code>glass_prim(mod, ident, tr, tg, tb, refrac=1.52)</code>","text":"<p>Generate a glass material.</p> <p>Parameters:</p> Name Type Description Default <code>mod</code> <code>str</code> <p>modifier to the primitive</p> required <code>ident</code> <code>str</code> <p>identifier to the primtive</p> required <code>tr,</code> <code>tg, tb (float</code> <p>transmmisivity in each channel (0.0 - 1.0)</p> required <code>refrac</code> <code>float</code> <p>refraction index (default=1.52)</p> <code>1.52</code> <p>Returns:</p> Type Description <code>Primitive</code> <p>material primtive (dict)</p>"},{"location":"ref/#frads.utils.id_generator","title":"<code>id_generator(size=3, chars=None)</code>","text":"<p>Generate random characters.</p>"},{"location":"ref/#frads.utils.lambda_calc","title":"<code>lambda_calc(theta_lr, theta_up, nphi)</code>","text":"<p>.</p>"},{"location":"ref/#frads.utils.material_lib","title":"<code>material_lib()</code>","text":"<p>Generate a list of generic material primitives.</p>"},{"location":"ref/#frads.utils.neutral_plastic_prim","title":"<code>neutral_plastic_prim(mod, ident, refl, spec, rough)</code>","text":"<p>Generate a neutral color plastic material.</p> <p>Parameters:</p> Name Type Description Default <code>mod(str)</code> <p>modifier to the primitive</p> required <code>ident(str)</code> <p>identifier to the primitive</p> required <code>refl</code> <code>float</code> <p>measured reflectance (0.0 - 1.0)</p> required <code>specu</code> <code>float</code> <p>material specularity (0.0 - 1.0)</p> required <code>rough</code> <code>float</code> <p>material roughness (0.0 - 1.0)</p> required <p>Returns:</p> Type Description <code>Primitive</code> <p>A material primtive</p>"},{"location":"ref/#frads.utils.neutral_trans_prim","title":"<code>neutral_trans_prim(mod, ident, trans, refl, spec, rough)</code>","text":"<p>Generate a neutral color plastic material.</p> <p>Parameters:</p> Name Type Description Default <code>mod(str)</code> <p>modifier to the primitive</p> required <code>ident(str)</code> <p>identifier to the primitive</p> required <code>refl</code> <code>float</code> <p>measured reflectance (0.0 - 1.0)</p> required <code>specu</code> <code>float</code> <p>material specularity (0.0 - 1.0)</p> required <code>rough</code> <code>float</code> <p>material roughness (0.0 - 1.0)</p> required <p>Returns:</p> Type Description <code>Primitive</code> <p>A material primtive</p>"},{"location":"ref/#frads.utils.opt2list","title":"<code>opt2list(opt)</code>","text":"<p>Convert option dictionary to list.</p> <p>Key: str Value: str | float | int | bool | list</p> <p>Parameters:</p> Name Type Description Default <code>opt</code> <code>dict</code> <p>option dictionary</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of strings</p>"},{"location":"ref/#frads.utils.polygon2prim","title":"<code>polygon2prim(polygon, modifier, identifier)</code>","text":"<p>Generate a primitive from a polygon.</p>"},{"location":"ref/#frads.utils.primitive_normal","title":"<code>primitive_normal(primitive_paths)</code>","text":"<p>Return a set of normal vectors given a list of primitive paths.</p>"},{"location":"ref/#frads.utils.pt_inclusion","title":"<code>pt_inclusion(pt, polygon_pts)</code>","text":"<p>Test whether a point is inside a polygon using winding number algorithm.</p>"},{"location":"ref/#frads.utils.run_write","title":"<code>run_write(command, out, stdin=None)</code>","text":"<p>Run command and write stdout to file.</p>"},{"location":"ref/#frads.utils.samp_dir","title":"<code>samp_dir(primlist)</code>","text":"<p>Calculate the primitives' average sampling direction weighted by area.</p>"},{"location":"ref/#frads.utils.sdata2bsdf","title":"<code>sdata2bsdf(sdata)</code>","text":"<p>Convert sdata object to bsdf object.</p>"},{"location":"ref/#frads.utils.square2disk","title":"<code>square2disk(in_square_a, in_square_b)</code>","text":"<p>Shirley-Chiu square to disk mapping.</p> <p>Parameters:</p> Name Type Description Default <code>in_square_a</code> <code>float</code> <p>[-1, 1]</p> required <code>in_square_b</code> <code>float</code> <p>[-1, 1]</p> required"},{"location":"ref/#frads.utils.tmit2tmis","title":"<code>tmit2tmis(tmit)</code>","text":"<p>Convert from transmittance to transmissivity.</p>"},{"location":"ref/#frads.utils.unpack_idf","title":"<code>unpack_idf(path)</code>","text":"<p>Read and parse and idf files.</p>"},{"location":"ref/#frads.utils.unpack_primitives","title":"<code>unpack_primitives(file)</code>","text":"<p>Open a file a to parse primitive.</p>"},{"location":"ref/#frads.utils.up_vector","title":"<code>up_vector(primitives)</code>","text":"<p>Define the up vector given primitives.</p> <p>Parameters:</p> Name Type Description Default <code>primitives</code> <code>list</code> <p>list of dictionary (primitives)</p> required <p>Returns:</p> Type Description <code>geom.Vector</code> <p>returns a str as x,y,z</p>"},{"location":"ref/#frads.matrix","title":"<code>frads.matrix</code>","text":"<p>This module contains routines to generate sender and receiver objects, generate matrices by calling either rfluxmtx or rcontrib.</p>"},{"location":"ref/#frads.matrix.points_as_sender","title":"<code>points_as_sender(pts_list, ray_cnt=None)</code>","text":"<p>Construct a sender from a list of points.</p> <p>Parameters:</p> Name Type Description Default <code>pts_list(list)</code> <p>a list of list of float</p> required <code>ray_cnt(int)</code> <p>sender ray count</p> required <p>Returns:</p> Type Description <code>Sender</code> <p>A sender object</p>"},{"location":"ref/#frads.matrix.prepare_surface","title":"<code>prepare_surface(*, prims, basis, left, offset, source, out)</code>","text":"<p>Prepare the sender or receiver surface, adding appropriate tags.</p> <p>Parameters:</p> Name Type Description Default <code>prims(list)</code> <p>list of primitives</p> required <code>basis(str)</code> <p>sampling basis</p> required <code>left(bool)</code> <p>use instead the left-hand rule</p> required <code>offset(float)</code> <p>offset surface in its normal direction</p> required <code>source(str)</code> <p>surface light source for receiver</p> required <code>out</code> <p>output path</p> required <p>Returns:</p> Type Description <code>str</code> <p>The surface sender/receiver primitive as string</p>"},{"location":"ref/#frads.matrix.rcontrib","title":"<code>rcontrib(sender, modifier, octree, out, opt)</code>","text":"<p>Calling rcontrib to generate the matrices.</p> <p>Parameters:</p> Name Type Description Default <code>sender</code> <p>Sender object</p> required <code>modifier</code> <code>str</code> <p>modifier str listing the receivers in octree</p> required <code>octree</code> <code>Union[str, Path]</code> <p>the octree that includes the environment and the receiver</p> required <code>opt</code> <code>List[str]</code> <p>option string</p> required <code>out</code> <code>Union[str, Path]</code> <p>output path</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"ref/#frads.matrix.rcvr_oct","title":"<code>rcvr_oct(receiver, env, oct_path)</code>","text":"<p>Generate an octree of the environment and the receiver.</p> <p>Parameters:</p> Name Type Description Default <code>receiver</code> <p>receiver object</p> required <code>env</code> <p>environment file paths</p> required <code>oct_path</code> <code>Union[str, Path]</code> <p>Path to write the octree to</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"ref/#frads.matrix.rfluxmtx","title":"<code>rfluxmtx(sender, receiver, env, opt=None)</code>","text":"<p>Calling rfluxmtx to generate the matrices.</p> <p>Parameters:</p> Name Type Description Default <code>sender</code> <code>Sender</code> <p>Sender object</p> required <code>receiver</code> <code>Receiver</code> <p>Receiver object</p> required <code>env</code> <code>Iterable[Path]</code> <p>model environment, basically anything that's not the sender or receiver</p> required <code>opt</code> <code>Optional[List[str]]</code> <p>option string</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>return the stdout of the rfluxmtx run.</p>"},{"location":"ref/#frads.matrix.sky_as_receiver","title":"<code>sky_as_receiver(basis, out)</code>","text":"<p>Instantiate a sky receiver object.</p> <p>Parameters:</p> Name Type Description Default <code>basis</code> <code>str</code> <p>receiver sampling basis {kf | r1 | sc25...}</p> required <p>Returns:</p> Type Description <code>Receiver</code> <p>A sky receiver object</p>"},{"location":"ref/#frads.matrix.sun_as_receiver","title":"<code>sun_as_receiver(basis, smx_path, window_normals, full_mod=False)</code>","text":"<p>Instantiate a sun receiver object.</p> <p>Parameters:</p> Name Type Description Default <code>basis</code> <p>receiver sampling basis {kf | r1 | sc25...}</p> required <code>smx_path</code> <code>Path</code> <p>sky/sun matrix file path</p> required <code>window_paths</code> <p>window file paths</p> required <p>Returns:</p> Type Description <code>Receiver</code> <p>A sun receiver object</p>"},{"location":"ref/#frads.matrix.surface_as_receiver","title":"<code>surface_as_receiver(prim_list, basis, out, offset=None, left=False, source='glow')</code>","text":"<p>Instantiate a surface receiver object.</p> <p>Parameters:</p> Name Type Description Default <code>prim_list</code> <code>Sequence[Primitive]</code> <p>list of primitives(dict)</p> required <code>basis</code> <code>str</code> <p>receiver sampling basis {kf | r1 | sc25...}</p> required <code>out</code> <code>Union[None, str, Path]</code> <p>output path</p> required <code>offset</code> <p>offset the surface in its normal direction</p> <code>None</code> <code>left</code> <code>bool</code> <p>use instead left-hand rule for matrix generation</p> <code>False</code> <code>source</code> <code>str</code> <p>light source for receiver object {glow|light}</p> <code>'glow'</code> <p>Returns:</p> Type Description <code>Receiver</code> <p>A surface receiver object</p>"},{"location":"ref/#frads.matrix.surface_as_sender","title":"<code>surface_as_sender(prim_list, basis, offset=None, left=None)</code>","text":"<p>Construct a sender from a surface.</p> <p>Parameters:</p> Name Type Description Default <code>prim_list(list)</code> <p>a list of primitives</p> required <code>basis(str)</code> <p>sender sampling basis</p> required <code>offset(float)</code> <p>move the sender surface in its normal direction</p> required <code>left(bool)</code> <p>Use left-hand rule instead for matrix generation</p> required <p>Returns:</p> Type Description <code>Sender</code> <p>A sender object (Sender)</p>"},{"location":"ref/#frads.matrix.view_as_sender","title":"<code>view_as_sender(view, ray_cnt, xres, yres)</code>","text":"<p>Construct a sender from a view.</p> <p>Parameters:</p> Name Type Description Default <code>view</code> <code>View</code> <p>a view object;</p> required <code>ray_cnt</code> <code>int</code> <p>ray count;</p> required <code>xres,</code> <code>yres</code> <p>image resolution</p> required <code>c2c</code> <p>Set to True to trim the fisheye corner rays.</p> required <p>Returns:</p> Type Description <code>Sender</code> <p>A sender object</p>"}]}